# 同步原语

`asyncio `同步原语被设计为与` threading` 模块的类似，但有两个关键注意事项:

- asyncio 原语不是线程安全的，因此它们不应被用于 OS 线程同步 (而应当使用 threading)；

- 这些同步原语的方法不接受 timeout 参数；请使用 `asyncio.wait_for()` 函数来执行带有超时的操作。

`asyncio` 具有下列基本同步原语:

- Lock

- Event

- Condition

- Semaphore

- BoundedSemaphore

## Lock

`class asyncio.Lock(*, loop=None)`

- 为异步任务实现互斥锁。不是线程安全的。

- 异步锁可用于保证对共享资源的独占访问。

- 使用Lock的首选方式是 声明：`async with`

```python
lock = asyncio.Lock()

# ... later
async with lock:
    # access shared state
```

等效于：

```python
lock = asyncio.Lock()

# ... later
await lock.acquire()
try:
    # access shared state
finally:
    lock.release()
```

*从3.8版开始不推荐使用，将在3.10版中删除：loop*形参。

- `coroutine acquire`()

  获取锁。

  此方法将等待直到锁被解锁，然后将其设置为 锁定并返回True。

  当一个以上的协程被阻止acquire() 等待锁被解锁时，最终只有一个协程进行。

  获取锁是公平的：继续执行的协程将是开始等待锁的第一个协程。

- `release`()

  释放锁。

  锁锁定后，将其重置为解锁状态并返回。

  如果锁已解锁，RuntimeError则会引发.

- `locked()`

  如果锁已锁定，则返回True。

## Event

- `class asyncio.Event(*, loop=None)`

  事件对象。不是线程安全的。

  异步事件可用于通知多个异步任务某个事件已发生。

  事件对象管理可被设置为一个内部标志真正 与set()方法和复位为假与 clear()方法。该wait()方法将阻塞，直到该标志设置为true为止。该标志最初设置为false。

  *从3.8版开始不推荐使用，将在3.10版中删除：loop形参。*

  示例:

  ```python
  async def waiter(event):
      print('waiting for it ...')
      await event.wait()
      print('... got it!')
  
  async def main():
      # Create an Event object.
      event = asyncio.Event()
  
      # Spawn a Task to wait until 'event' is set.
      waiter_task = asyncio.create_task(waiter(event))
  
      # Sleep for 1 second and set the event.
      await asyncio.sleep(1)
      event.set()
  
      # Wait until the waiter task is finished.
      await waiter_task
  
  asyncio.run(main())
  ```

- `coroutine wait()`

  等待事件设置。

  如果设置了事件，请True立即返回。否则，阻塞直到另一个任务调用set()。

- `set()`

  设置事件。

  等待事件设置的所有任务将立即唤醒。

- `clear()`

  清除（取消设置）事件。

  wait()现在，等待执行的任务将阻塞，直到set()再次调用该方法为止 。

- `is_set()`

  如果设置了事件，则返回True。

## Condition

`class asyncio.Condition(lock=None, *, loop=None)`

条件对象。不是线程安全的。

任务可以使用异步条件原语来等待某个事件发生，然后获得对共享资源的独占访问。

本质上，Condition对象结合了Event和Lock的功能。可能有多个Condition对象共享一个Lock，这允许在对该共享资源的特定状态感兴趣的不同任务之间协调对共享资源的互斥访问。

可选的lock参数必须是Lock对象或 None。在后一种情况下，将自动创建一个新的Lock对象。

*从3.8版开始不推荐使用，将在3.10版中删除：loop形参。*

使用条件的首选方式是 声明：`async with`

```python
cond = asyncio.Condition()

# ... later
async with cond:
    await cond.wait()
```

等效于：

```python
cond = asyncio.Condition()

# ... later
await cond.acquire()
try:
    await cond.wait()
finally:
    cond.release()
```

- `coroutine acquire()`

  获取基础锁。

  此方法等待直到基础锁被解锁，然后将其设置为锁定并返回True。

- `notify(n=1)`

  在这种情况下最多唤醒n个任务（默认为1个）。如果没有任务在等待，则该方法为无操作。

  必须在调用此方法之前获取该锁，并在此之后不久将其释放。如果使用解锁的锁调用，r则会引发RuntimeErro错误。

- `locked()`

  True如果获取了基础锁，则返回。

- `notify_all()`

  唤醒所有在这种情况下等待的任务。

  此方法的行为类似于notify()，但唤醒所有等待的任务。

  必须在调用此方法之前获取该锁，并在此之后不久将其释放。如果使用解锁的锁调用，则会引发RuntimeError错误。

- `release()`

  释放基础锁。

  在未锁定的锁调用时，会引发 RuntimeError 异常。

- `coroutine wait()`

  唤醒所有在这种情况下等待的任务。

  此方法的行为类似于notify()，但唤醒所有等待的任务。

  必须在调用此方法之前获取该锁，并在此之后不久将其释放。如果使用解锁的锁调用，则会引发RuntimeError错误。

- `coroutine wait_for(predicate)`

  等到predicate变为真。

  predicate必须是可调用的，其结果将被解释为布尔值。最终值是返回值。

## Semaphore

`class asyncio.Semaphore(value=1, *, loop=None)`

信号量对象。不是线程安全的。

信号量管理一个内部计数器，该内部计数器随每个acquire()调用而递减，并随每个 调用而递增release()。计数器永远不能低于零。当acquire()发现它为零时，它将阻塞，直到某些任务调用为止 release()。

可选的value参数提供内部计数器的初始值（1默认情况下）。如果给定值小于0a，ValueError则引发。

从3.8版开始不推荐使用，将在3.10版中删除：loop形参。

使用信号量的首选方法是 声明：`async with`

```python
sem = asyncio.Semaphore(10)

# ... later
async with sem:
    # work with shared resource
```

等效于：

```python
sem = asyncio.Semaphore(10)

# ... later
await sem.acquire()
try:
    # work with shared resource
finally:
    sem.release()
```

- `coroutine acquire()`

  获取一个信号量。

  如果内部计数器大于零，则将其递减一并True立即返回。如果为零，则等待直到release()调用并返回True。

- `locked()`

  如果无法立即获取信号量，则返回True。

- `release()`

  ease()
  释放信号量，使内部计数器增加一。可以唤醒等待获取信号量的任务。

  与`BoundedSemaphore`相比，`Semaphore`允许release()拨打的电话多于acquire()通话的电话。

## BoundedSemaphore

`class asyncio.BoundedSemaphore(value=1, *, loop=None)`

有界信号量对象。不是线程安全的。

Bounded Semaphore是一种信号量版本，如果它将内部计数器增加到初始值以上，它将在release（）中引发ValueError。

*从3.8版开始不推荐使用，将在3.10版中删除：loop形参。*

*在 3.9 版更改: 使用`await lock`或`yield from lock`和`/`或`with`语句`（with await lock，with（yield from lock））`获取锁的操作被删除。请改用`async with lock`。*

