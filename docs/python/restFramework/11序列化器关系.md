# [序列化器关系](https://www.django-rest-framework.org/api-guide/relations/#serializer-relations)

> 数据结构而非算法是编程的核心。
>
> — [罗伯·派克](http://users.ece.utexas.edu/~adnan/pike.html)

关系字段用于表示模型关系。它们可以应用到`ForeignKey`，`ManyToManyField`和`OneToOneField`关系，以及对反向关系，自定义关系等`GenericForeignKey`。

------

**注意：**关系字段是在中声明的`relations.py`，但按照惯例，您应`serializers`使用`from rest_framework import serializers`并将其称为，从模块中导入它们`serializers.`。

------

#### [检查关系。](https://www.django-rest-framework.org/api-guide/relations/#inspecting-relationships)

使用`ModelSerializer`该类时，将为您自动生成序列化程序字段和关系。检查这些自动生成的字段可能是确定如何自定义关系样式的有用工具。

为此，请使用打开Django Shell，`python manage.py shell`然后导入序列化程序类，实例化它，然后打印对象表示形式…

```python
>>> from myapp.serializers import AccountSerializer
>>> serializer = AccountSerializer()
>>> print(repr(serializer))
AccountSerializer():
    id = IntegerField(label='ID', read_only=True)
    name = CharField(allow_blank=True, max_length=100, required=False)
    owner = PrimaryKeyRelatedField(queryset=User.objects.all())
```

# [API参考](https://www.django-rest-framework.org/api-guide/relations/#api-reference)

为了解释各种类型的关系字段，我们将为示例使用几个简单的模型。我们的模型将用于音乐专辑，以及每个专辑中列出的曲目。

```python
class Album(models.Model):
    album_name = models.CharField(max_length=100)
    artist = models.CharField(max_length=100)

class Track(models.Model):
    album = models.ForeignKey(Album, related_name='tracks', on_delete=models.CASCADE)
    order = models.IntegerField()
    title = models.CharField(max_length=100)
    duration = models.IntegerField()

    class Meta:
        unique_together = ['album', 'order']
        ordering = ['order']

    def __str__(self):
        return '%d: %s' % (self.order, self.title)
```

## [StringRelatedField](https://www.django-rest-framework.org/api-guide/relations/#stringrelatedfield)

`StringRelatedField`可使用其`__str__`方法来表示关系的目标。

例如，下面的序列化器。

```python
class AlbumSerializer(serializers.ModelSerializer):
    tracks = serializers.StringRelatedField(many=True)

    class Meta:
        model = Album
        fields = ['album_name', 'artist', 'tracks']
```

将序列化为以下表示形式。

```python
{
    'album_name': 'Things We Lost In The Fire',
    'artist': 'Low',
    'tracks': [
        '1: Sunflower',
        '2: Whitetail',
        '3: Dinosaur Act',
        ...
    ]
}
```

该字段是只读的。

**参数**：

- `many`-如果应用于多对多关系，则应将此参数设置为`True`。

## [PrimaryKeyRelatedField](https://www.django-rest-framework.org/api-guide/relations/#primarykeyrelatedfield)

`PrimaryKeyRelatedField` 可以用于通过关系的主键表示关系的目标。

例如，以下序列化器：

```python
class AlbumSerializer(serializers.ModelSerializer):
    tracks = serializers.PrimaryKeyRelatedField(many=True, read_only=True)

    class Meta:
        model = Album
        fields = ['album_name', 'artist', 'tracks']
```

将序列化为这样的表示形式：

```python
{
    'album_name': 'Undun',
    'artist': 'The Roots',
    'tracks': [
        89,
        90,
        91,
        ...
    ]
}
```

默认情况下，此字段是可读写的，尽管您可以使用该`read_only`标志更改此行为。

**参数**：

- `queryset`-验证字段输入时用于模型实例查找的查询集。关系必须显式设置queryset或set `read_only=True`。
- `many`-如果应用于多对多关系，则应将此参数设置为`True`。
- `allow_null`-如果设置为`True`，则该字段将接受`None`可空关系的值或空字符串。默认为`False`。
- `pk_field`-设置为一个字段以控制主键值的序列化/反序列化。例如，`pk_field=UUIDField(format='hex')`将UUID主键序列化为其紧凑的十六进制表示形式。

## [超链接相关字段](https://www.django-rest-framework.org/api-guide/relations/#hyperlinkedrelatedfield)

`HyperlinkedRelatedField` 可以用于通过超链接表示关系的目标。

例如，以下序列化器：

```python
class AlbumSerializer(serializers.ModelSerializer):
    tracks = serializers.HyperlinkedRelatedField(
        many=True,
        read_only=True,
        view_name='track-detail'
    )

    class Meta:
        model = Album
        fields = ['album_name', 'artist', 'tracks']
```

将序列化为这样的表示形式：

```python
{
    'album_name': 'Graceland',
    'artist': 'Paul Simon',
    'tracks': [
        'http://www.example.com/api/tracks/45/',
        'http://www.example.com/api/tracks/46/',
        'http://www.example.com/api/tracks/47/',
        ...
    ]
}
```

默认情况下，此字段是可读写的，尽管您可以使用该`read_only`标志更改此行为。

------

**注意**：此字段是为那些映射到URL的对象设计的，该URL接受使用`lookup_field`和`lookup_url_kwarg`参数设置的单个URL关键字参数。

这适用于包含单个主键或slug参数作为URL一部分的URL。

如果您需要更复杂的超链接表示形式，则需要自定义字段，如下面的“ [自定义超链接字段”](https://www.django-rest-framework.org/api-guide/relations/#custom-hyperlinked-fields)部分所述。

------

**参数**：

- `view_name`-应该用作关系目标的视图名称。如果您使用的[是标准路由器类，](https://www.django-rest-framework.org/api-guide/routers#defaultrouter)则它将是一个格式为的字符串`-detail`。**必需的**。
- `queryset`-验证字段输入时用于模型实例查找的查询集。关系必须显式设置queryset或set `read_only=True`。
- `many`-如果应用于多对多关系，则应将此参数设置为`True`。
- `allow_null`-如果设置为`True`，则该字段将接受`None`可空关系的值或空字符串。默认为`False`。
- `lookup_field`-目标上应用于查找的字段。应该对应于引用视图上的URL关键字参数。默认值为`'pk'`。
- `lookup_url_kwarg`-在URL conf中定义的与查找字段相对应的关键字参数的名称。默认使用与相同的值`lookup_field`。
- `format`-如果使用格式后缀，则超链接字段将为目标使用相同的格式后缀，除非使用`format`参数将其覆盖。

## [SlugRelatedField](https://www.django-rest-framework.org/api-guide/relations/#slugrelatedfield)

`SlugRelatedField` 可以使用目标上的字段来表示关系的目标。

例如，以下序列化器：

```python
class AlbumSerializer(serializers.ModelSerializer):
    tracks = serializers.SlugRelatedField(
        many=True,
        read_only=True,
        slug_field='title'
     )

    class Meta:
        model = Album
        fields = ['album_name', 'artist', 'tracks']
```

将序列化为这样的表示形式：

```python
{
    'album_name': 'Dear John',
    'artist': 'Loney Dear',
    'tracks': [
        'Airport Surroundings',
        'Everything Turns to You',
        'I Was Only Going Out',
        ...
    ]
}
```

默认情况下，此字段是可读写的，尽管您可以使用该`read_only`标志更改此行为。

当使用`SlugRelatedField`作为一个读写字段，你通常会希望确保塞字段对应于具有示范场`unique=True`。

**参数**：

- `slug_field`-目标上用于表示它的字段。这应该是一个唯一标识任何给定实例的字段。例如，`username`。 **需要**
- `queryset`-验证字段输入时用于模型实例查找的查询集。关系必须显式设置queryset或set `read_only=True`。
- `many`-如果应用于多对多关系，则应将此参数设置为`True`。
- `allow_null`-如果设置为`True`，则该字段将接受`None`可空关系的值或空字符串。默认为`False`。

## [超链接身份字段](https://www.django-rest-framework.org/api-guide/relations/#hyperlinkedidentityfield)

该字段可以用作身份关系，例如`'url'`HyperlinkedModelSerializer上的字段。它也可以用于对象的属性。例如，以下序列化器：

```python
class AlbumSerializer(serializers.HyperlinkedModelSerializer):
    track_listing = serializers.HyperlinkedIdentityField(view_name='track-list')

    class Meta:
        model = Album
        fields = ['album_name', 'artist', 'track_listing']
```

将序列化为这样的表示形式：

```python
{
    'album_name': 'The Eraser',
    'artist': 'Thom Yorke',
    'track_listing': 'http://www.example.com/api/track_list/12/',
}
```

该字段始终是只读的。

**参数**：

- `view_name`-应该用作关系目标的视图名称。如果您使用的[是标准路由器类，](https://www.django-rest-framework.org/api-guide/routers#defaultrouter)则它将是一个格式为的字符串`-detail`。 **必需的**。
- `lookup_field`-目标上应用于查找的字段。应该对应于引用视图上的URL关键字参数。默认值为`'pk'`。
- `lookup_url_kwarg`-在URL conf中定义的与查找字段相对应的关键字参数的名称。默认使用与相同的值`lookup_field`。
- `format`-如果使用格式后缀，则超链接字段将为目标使用相同的格式后缀，除非使用`format`参数将其覆盖。

------

# [嵌套关系](https://www.django-rest-framework.org/api-guide/relations/#nested-relationships)

与先前讨论的对另一个实体的引用相反，所引用的实体也可以嵌入或*嵌套* 在*引用*该实体的对象的表示中。这样的嵌套关系可以通过使用序列化器作为字段来表达。

如果该字段用于表示一对多关系，则应将`many=True`标志添加到序列化器字段。

## [例](https://www.django-rest-framework.org/api-guide/relations/#example)

例如，以下序列化器：

```python
class TrackSerializer(serializers.ModelSerializer):
    class Meta:
        model = Track
        fields = ['order', 'title', 'duration']

class AlbumSerializer(serializers.ModelSerializer):
    tracks = TrackSerializer(many=True, read_only=True)

    class Meta:
        model = Album
        fields = ['album_name', 'artist', 'tracks']
```

将序列化为这样的嵌套表示形式：

```python
>>> album = Album.objects.create(album_name="The Grey Album", artist='Danger Mouse')
>>> Track.objects.create(album=album, order=1, title='Public Service Announcement', duration=245)
<Track: Track object>
>>> Track.objects.create(album=album, order=2, title='What More Can I Say', duration=264)
<Track: Track object>
>>> Track.objects.create(album=album, order=3, title='Encore', duration=159)
<Track: Track object>
>>> serializer = AlbumSerializer(instance=album)
>>> serializer.data
{
    'album_name': 'The Grey Album',
    'artist': 'Danger Mouse',
    'tracks': [
        {'order': 1, 'title': 'Public Service Announcement', 'duration': 245},
        {'order': 2, 'title': 'What More Can I Say', 'duration': 264},
        {'order': 3, 'title': 'Encore', 'duration': 159},
        ...
    ],
}
```

## [可写的嵌套序列化器](https://www.django-rest-framework.org/api-guide/relations/#writable-nested-serializers)

默认情况下，嵌套串行器是只读的。如果要支持对嵌套序列化器字段的写操作，则需要创建`create()`和/或`update()`方法，以明确指定应如何保存子关系。

```python
class TrackSerializer(serializers.ModelSerializer):
    class Meta:
        model = Track
        fields = ['order', 'title', 'duration']

class AlbumSerializer(serializers.ModelSerializer):
    tracks = TrackSerializer(many=True)

    class Meta:
        model = Album
        fields = ['album_name', 'artist', 'tracks']

    def create(self, validated_data):
        tracks_data = validated_data.pop('tracks')
        album = Album.objects.create(**validated_data)
        for track_data in tracks_data:
            Track.objects.create(album=album, **track_data)
        return album

>>> data = {
    'album_name': 'The Grey Album',
    'artist': 'Danger Mouse',
    'tracks': [
        {'order': 1, 'title': 'Public Service Announcement', 'duration': 245},
        {'order': 2, 'title': 'What More Can I Say', 'duration': 264},
        {'order': 3, 'title': 'Encore', 'duration': 159},
    ],
}
>>> serializer = AlbumSerializer(data=data)
>>> serializer.is_valid()
True
>>> serializer.save()
<Album: Album object>
```

------

# [自定义关系字段](https://www.django-rest-framework.org/api-guide/relations/#custom-relational-fields)

在极少数情况下，现有关系样式都不适合您所需的表示形式，您可以实现一个完全自定义的关系字段，该字段精确描述了应如何从模型实例生成输出表示形式。

要实现自定义关系字段，您应该重写`RelatedField`，并实现`.to_representation(self, value)`方法。此方法将字段的目标作为`value`参数，并应返回用于序列化目标的表示形式。该`value`参数通常是一个模型实例。

如果要实现读写关系字段，则还必须实现该`.to_internal_value(self, data)`方法。

要提供基于的动态查询集`context`，您还可以覆盖`.get_queryset(self)`而不是`.queryset`在类上或在初始化字段时指定。

## [例](https://www.django-rest-framework.org/api-guide/relations/#example_1)

例如，我们可以定义一个关系字段，以使用其顺序，标题和持续时间将轨道序列化为自定义字符串表示形式。

```python
import time

class TrackListingField(serializers.RelatedField):
    def to_representation(self, value):
        duration = time.strftime('%M:%S', time.gmtime(value.duration))
        return 'Track %d: %s (%s)' % (value.order, value.name, duration)

class AlbumSerializer(serializers.ModelSerializer):
    tracks = TrackListingField(many=True)

    class Meta:
        model = Album
        fields = ['album_name', 'artist', 'tracks']
```

然后，此自定义字段将序列化为以下表示形式。

```python
{
    'album_name': 'Sometimes I Wish We Were an Eagle',
    'artist': 'Bill Callahan',
    'tracks': [
        'Track 1: Jim Cain (04:39)',
        'Track 2: Eid Ma Clack Shaw (04:19)',
        'Track 3: The Wind and the Dove (04:34)',
        ...
    ]
}
```

------

# [自定义超链接字段](https://www.django-rest-framework.org/api-guide/relations/#custom-hyperlinked-fields)

在某些情况下，您可能需要自定义超链接字段的行为，以表示需要多个查询字段的URL。

您可以通过覆盖实现此目的`HyperlinkedRelatedField`。可以重写两种方法：

**get_url（self，obj，view_name，request，format）**

该`get_url`方法用于将对象实例映射到其URL表示形式。

`NoReverseMatch`如果`view_name`和`lookup_field` 属性未配置为正确匹配URL conf，则可能会引发。

**get_object（self，view_name，view_args，view_kwargs）**

如果要支持可写的超链接字段，则还需要覆盖`get_object`，以便将传入的URL映射回它们表示的对象。对于只读超链接字段，无需重写此方法。

此方法的返回值应为与匹配的URL conf参数相对应的对象。

可能会引发`ObjectDoesNotExist`异常。

## [例](https://www.django-rest-framework.org/api-guide/relations/#example_2)

假设我们有一个带两个关键字参数的customer对象的URL，如下所示：

```python
/api/<organization_slug>/customers/<customer_pk>/
```

这不能用默认实现表示，默认实现只接受一个查询字段。

在这种情况下，我们需要重写`HyperlinkedRelatedField`以获得所需的行为：

```python
from rest_framework import serializers
from rest_framework.reverse import reverse

class CustomerHyperlink(serializers.HyperlinkedRelatedField):
    # We define these as class attributes, so we don't need to pass them as arguments.
    view_name = 'customer-detail'
    queryset = Customer.objects.all()

    def get_url(self, obj, view_name, request, format):
        url_kwargs = {
            'organization_slug': obj.organization.slug,
            'customer_pk': obj.pk
        }
        return reverse(view_name, kwargs=url_kwargs, request=request, format=format)

    def get_object(self, view_name, view_args, view_kwargs):
        lookup_kwargs = {
           'organization__slug': view_kwargs['organization_slug'],
           'pk': view_kwargs['customer_pk']
        }
        return self.get_queryset().get(**lookup_kwargs)
```

请注意，如果您想将此样式与通用视图一起使用，则还需要`.get_object`在视图上进行覆盖，以获取正确的查找行为。

通常，对于可能的API表示形式，我们建议使用扁平样式，但是在进行审核时，嵌套的URL样式也可能是合理的。

------

# [进一步说明](https://www.django-rest-framework.org/api-guide/relations/#further-notes)

## [该`queryset`参数](https://www.django-rest-framework.org/api-guide/relations/#the-queryset-argument)

该`queryset`参数仅是*可写*关系字段所必需的，在这种情况下，该参数用于执行从原始用户输入映射到模型实例的模型实例查找。

在版本2.xa串类可以*有时*自动确定`queryset`参数*，如果*一个`ModelSerializer`正在使用的类了。

现在，此行为已替换为*始终*`queryset`对可写关系字段使用显式参数。

这样做可以减少`ModelSerializer`提供的隐藏“魔术”的数量，使字段的行为更清晰，并确保在使用`ModelSerializer`快捷方式或使用完全显式的`Serializer`类之间进行切换很简单。

## [自定义HTML显示](https://www.django-rest-framework.org/api-guide/relations/#customizing-the-html-display)

模型的内置`__str__`方法将用于生成用于填充`choices`属性的对象的字符串表示形式。这些选项用于填充可浏览API中的选定HTML输入。

要为这种投入提供定制化表示，覆盖`display_value()`一个的`RelatedField`子类。此方法将接收模型对象，并应返回适合于表示它的字符串。例如：

```python
class TrackPrimaryKeyRelatedField(serializers.PrimaryKeyRelatedField):
    def display_value(self, instance):
        return 'Track: %s' % (instance.title)
```

## [选择场截止](https://www.django-rest-framework.org/api-guide/relations/#select-field-cutoffs)

当在可浏览的API中呈现时，关系字段将默认为仅显示最多1000个可选项目。如果存在更多项目，则将显示带有“超过1000个项目…”的禁用选项。

此行为旨在防止由于显示大量关系而导致模板无法在可接受的时间范围内呈现。

您可以使用两个关键字参数来控制此行为：

- `html_cutoff`-如果设置，则将是HTML select下拉列表将显示的最大选择数。设置为`None`禁用任何限制。默认为`1000`。
- `html_cutoff_text`-如果设置了此选项，则如果在HTML选择下拉列表中已截断最大数量的项目，则它将显示文本指示器。默认为`"More than {count} items…"`

您还可以使用设置`HTML_SELECT_CUTOFF`和全局控制这些设置`HTML_SELECT_CUTOFF_TEXT`。

在强制执行截止的情况下，您可能需要改用HTML表单中的纯输入字段。您可以使用`style`关键字参数来实现。例如：

```python
assigned_to = serializers.SlugRelatedField(
   queryset=User.objects.all(),
   slug_field='username',
   style={'base_template': 'input.html'}
)
```

## [反向关系](https://www.django-rest-framework.org/api-guide/relations/#reverse-relations)

请注意，`ModelSerializer`和`HyperlinkedModelSerializer`类不会自动包含反向关系。要包括反向关系，必须将其显式添加到字段列表中。例如：

```python
class AlbumSerializer(serializers.ModelSerializer):
    class Meta:
        fields = ['tracks', ...]
```

通常，您需要确保`related_name`在关系上设置了适当的参数，可以用作字段名称。例如：

```python
class Track(models.Model):
    album = models.ForeignKey(Album, related_name='tracks', on_delete=models.CASCADE)
    ...
```

如果尚未为反向关系设置相关名称，则需要在`fields`参数中使用自动生成的相关名称。例如：

```python
class AlbumSerializer(serializers.ModelSerializer):
    class Meta:
        fields = ['track_set', ...]
```

有关更多详细信息，请参见关于[反向关系](https://docs.djangoproject.com/en/stable/topics/db/queries/#following-relationships-backward)的Django文档。

## [通用关系](https://www.django-rest-framework.org/api-guide/relations/#generic-relationships)

如果要序列化通用外键，则需要定义一个自定义字段，以明确确定要序列化关系目标的方式。

例如，给定标记的以下模型，该模型与其他任意模型具有通用关系：

```python
class TaggedItem(models.Model):
    """
    Tags arbitrary model instances using a generic relation.

    See: https://docs.djangoproject.com/en/stable/ref/contrib/contenttypes/
    """
    tag_name = models.SlugField()
    content_type = models.ForeignKey(ContentType, on_delete=models.CASCADE)
    object_id = models.PositiveIntegerField()
    tagged_object = GenericForeignKey('content_type', 'object_id')

    def __str__(self):
        return self.tag_name
```

还有以下两个模型，它们可能具有关联的标签：

```python
class Bookmark(models.Model):
    """
    A bookmark consists of a URL, and 0 or more descriptive tags.
    """
    url = models.URLField()
    tags = GenericRelation(TaggedItem)


class Note(models.Model):
    """
    A note consists of some text, and 0 or more descriptive tags.
    """
    text = models.CharField(max_length=1000)
    tags = GenericRelation(TaggedItem)
```

我们可以定义一个自定义字段，该字段可用于序列化带标签的实例，使用每个实例的类型来确定应如何序列化它。

```python
class TaggedObjectRelatedField(serializers.RelatedField):
    """
    A custom field to use for the `tagged_object` generic relationship.
    """

    def to_representation(self, value):
        """
        Serialize tagged objects to a simple textual representation.
        """
        if isinstance(value, Bookmark):
            return 'Bookmark: ' + value.url
        elif isinstance(value, Note):
            return 'Note: ' + value.text
        raise Exception('Unexpected type of tagged object')
```

如果需要关系的目标具有嵌套表示，则可以在`.to_representation()`方法内部使用所需的序列化器：

```python
    def to_representation(self, value):
        """
        Serialize bookmark instances using a bookmark serializer,
        and note instances using a note serializer.
        """
        if isinstance(value, Bookmark):
            serializer = BookmarkSerializer(value)
        elif isinstance(value, Note):
            serializer = NoteSerializer(value)
        else:
            raise Exception('Unexpected type of tagged object')

        return serializer.data
```

注意，使用`GenericRelation`字段表示的反向通用密钥可以使用常规的关系字段类型进行序列化，因为关系中目标的类型始终是已知的。

有关更多信息，请参见[有关通用关系的Django文档](https://docs.djangoproject.com/en/stable/ref/contrib/contenttypes/#id1)。

## [通过模型的ManyToManyFields](https://www.django-rest-framework.org/api-guide/relations/#manytomanyfields-with-a-through-model)

默认情况下，`ManyToManyField`以 `through`指定模型为目标的关系字段设置为只读。

如果您`ManyToManyField`使用直通模型明确指定指向的关系字段 ，请确保将其设置`read_only` 为`True`。

如果希望[在直通模型上](https://docs.djangoproject.com/en/2.2/topics/db/models/#intermediary-manytomany)表示[额外的字段，](https://docs.djangoproject.com/en/2.2/topics/db/models/#intermediary-manytomany)则可以将直通模型序列化为[嵌套对象](https://www.django-rest-framework.org/api-guide/serializers/#dealing-with-nested-objects)。

------

# [第三方套餐](https://www.django-rest-framework.org/api-guide/relations/#third-party-packages)

以下第三方软件包也可用。

## [DRF嵌套路由器](https://www.django-rest-framework.org/api-guide/relations/#drf-nested-routers)

的[DRF-嵌套的路由器包](https://github.com/alanjds/drf-nested-routers)提供路由器和关系字段用于与嵌套资源工作。

## [其余框架的一般关系](https://www.django-rest-framework.org/api-guide/relations/#rest-framework-generic-relations)

在[其余的框架，仿制关系](https://github.com/Ian-Foote/rest-framework-generic-relations)库提供了通用的外键的读/写序列化。