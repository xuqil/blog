# [验证者](https://www.django-rest-framework.org/api-guide/validators/#validators)

> 验证器对于在不同类型的字段之间重用验证逻辑很有用。
>
> — [Django文档](https://docs.djangoproject.com/en/stable/ref/validators/)

在大多数情况下，您在REST框架中处理验证时，您将仅依赖于默认字段验证，或者在序列化程序或字段类上编写显式验证方法。

但是，有时您希望将验证逻辑放入可重用的组件中，以便可以轻松地在整个代码库中重用它。这可以通过使用验证器函数和验证器类来实现。

## [REST框架中的验证](https://www.django-rest-framework.org/api-guide/validators/#validation-in-rest-framework)

Django REST框架序列化程序中的验证与Django `ModelForm`类中的验证工作方式略有不同。

与`ModelForm`所述验证形式的上部分地执行，并且部分地在模型实例。使用REST框架，验证完全在序列化程序类上执行。由于以下原因，这是有利的：

- 它引入了适当的关注点分离，使您的代码行为更加明显。
- 在使用快捷方式`ModelSerializer`类和使用显式`Serializer`类之间进行切换很容易。用于的任何验证行为`ModelSerializer`都很容易复制。
- 打印`repr`序列化程序实例的，将确切显示它适用的验证规则。在模型实例上没有调用任何额外的隐藏验证行为。

使用时，`ModelSerializer`所有这些都会自动为您处理。如果要改为使用`Serializer`类，则需要显式定义验证规则。

#### [例](https://www.django-rest-framework.org/api-guide/validators/#example)

作为REST框架如何使用显式验证的示例，我们将使用一个简单的模型类，该类具有一个具有唯一性约束的字段。

```python
class CustomerReportRecord(models.Model):
    time_raised = models.DateTimeField(default=timezone.now, editable=False)
    reference = models.CharField(unique=True, max_length=20)
    description = models.TextField()
```

这`ModelSerializer`是我们可以用来创建或更新实例的基础`CustomerReportRecord`：

```python
class CustomerReportSerializer(serializers.ModelSerializer):
    class Meta:
        model = CustomerReportRecord
```

如果我们使用以下方法打开Django shell，`manage.py shell`我们现在可以

```python
>>> from project.example.serializers import CustomerReportSerializer
>>> serializer = CustomerReportSerializer()
>>> print(repr(serializer))
CustomerReportSerializer():
    id = IntegerField(label='ID', read_only=True)
    time_raised = DateTimeField(read_only=True)
    reference = CharField(max_length=20, validators=[<UniqueValidator(queryset=CustomerReportRecord.objects.all())>])
    description = CharField(style={'type': 'textarea'})
```

这里有趣的是`reference`领域。我们可以看到，唯一性约束是由序列化器字段上的验证器显式实施的。

由于这种更明确的样式，REST框架包含了一些验证器类，而这些验证器类在核心Django中不可用。这些类在下面详细介绍。

------

## [UniqueValidator](https://www.django-rest-framework.org/api-guide/validators/#uniquevalidator)

该验证器可用于`unique=True`对模型字段实施约束。它带有一个必需的参数和一个可选的`messages`参数：

- `queryset` *必需* -这是应针对其强制执行唯一性的查询集。
- `message` -验证失败时应使用的错误消息。
- `lookup`-用于查找具有已验证值的现有实例的查找。默认为`'exact'`。

该验证器应应用于*序列化器字段*，如下所示：

```python
from rest_framework.validators import UniqueValidator

slug = SlugField(
    max_length=100,
    validators=[UniqueValidator(queryset=BlogPost.objects.all())]
)
```

## [UniqueTogetherValidator](https://www.django-rest-framework.org/api-guide/validators/#uniquetogethervalidator)

该验证器可用于`unique_together`对模型实例施加约束。它具有两个必需参数和一个可选`messages`参数：

- `queryset` *必需* -这是应针对其强制执行唯一性的查询集。
- `fields` *必填* -字段名称的列表或元组，应组成唯一的集合。这些必须作为字段存在于序列化程序类中。
- `message` -验证失败时应使用的错误消息。

验证器应应用于*序列化器类*，如下所示：

```python
from rest_framework.validators import UniqueTogetherValidator

class ExampleSerializer(serializers.Serializer):
    # ...
    class Meta:
        # ToDo items belong to a parent list, and have an ordering defined
        # by the 'position' field. No two items in a given list may share
        # the same position.
        validators = [
            UniqueTogetherValidator(
                queryset=ToDoItem.objects.all(),
                fields=['list', 'position']
            )
        ]
```

------

**注意**：`UniqueTogetherValidator`该类始终强加一个隐式约束，该类所应用的所有字段始终按要求处理。带有`default`值的字段是一个例外，因为即使从用户输入中省略，它们也始终提供一个值。

------

## [UniqueForDateValidator](https://www.django-rest-framework.org/api-guide/validators/#uniquefordatevalidator)

## [UniqueForMonthValidator](https://www.django-rest-framework.org/api-guide/validators/#uniqueformonthvalidator)

## [UniqueForYearValidator](https://www.django-rest-framework.org/api-guide/validators/#uniqueforyearvalidator)

这些验证可用于执行`unique_for_date`，`unique_for_month`和`unique_for_year`上模型实例的限制。他们采用以下参数：

- `queryset` *必需* -这是应针对其强制执行唯一性的查询集。
- `field` *必填* -将验证给定日期范围内的唯一性的字段名称。它必须作为序列化程序类上的字段存在。
- `date_field` *required-必填*字段名称，用于确定唯一性约束的日期范围。它必须作为序列化程序类上的字段存在。
- `message` -验证失败时应使用的错误消息。

验证器应应用于*序列化器类*，如下所示：

```python
from rest_framework.validators import UniqueForYearValidator

class ExampleSerializer(serializers.Serializer):
    # ...
    class Meta:
        # Blog posts should have a slug that is unique for the current year.
        validators = [
            UniqueForYearValidator(
                queryset=BlogPostItem.objects.all(),
                field='slug',
                date_field='published'
            )
        ]
```

始终要求序列号类上存在用于验证的日期字段。您不能简单地依赖模型类`default=...`，因为直到运行验证之后，才会生成用于默认值的值。

您可能要使用两种样式，具体取决于您希望API的行为方式。如果您正在使用`ModelSerializer`，则可能仅依赖于REST框架为您生成的默认值，但是如果您正在使用`Serializer`或仅希望进行更明确的控制，请使用下面演示的样式。

#### [与可写日期字段一起使用。](https://www.django-rest-framework.org/api-guide/validators/#using-with-a-writable-date-field)

如果您希望日期字段可写，则唯一需要注意的是，您应该通过设置`default`参数或通过设置来确保输入数据中日期字段始终可用`required=True`。

```python
published = serializers.DateTimeField(required=True)
```

#### [与只读日期字段一起使用。](https://www.django-rest-framework.org/api-guide/validators/#using-with-a-read-only-date-field)

如果希望日期字段可见，但用户不可编辑，则设置`read_only=True`并另外设置一个`default=...`参数。

```python
published = serializers.DateTimeField(read_only=True, default=timezone.now)
```

#### [与隐藏的日期字段一起使用。](https://www.django-rest-framework.org/api-guide/validators/#using-with-a-hidden-date-field)

如果您希望日期字段对用户完全隐藏，请使用`HiddenField`。此字段类型不接受用户输入，而是始终将其默认值返回给`validated_data`序列化器中的。

```python
published = serializers.HiddenField(default=timezone.now)
```

------

**注意**：这些`UniqueForValidator`类强加了一个隐式约束，即始终将按其要求应用它们的字段。带有`default`值的字段是一个例外，因为即使从用户输入中省略，它们也始终提供一个值。

------

# [高级字段默认值](https://www.django-rest-framework.org/api-guide/validators/#advanced-field-defaults)

了在串行化器在多个领域得到应用验证有时可以要求不应该由API客户端被提供一个字段输入，但*是*可作为输入提供给验证器。

您可能要用于这种验证的两种模式包括：

- 使用`HiddenField`。该字段将出现在串行器输出表示中，`validated_data`但*将不*使用。
- 与一起使用标准字段`read_only=True`，但其中还包含一个`default=…`参数。该字段*将*在序列化器输出表示中使用，但不能由用户直接设置。

REST框架包含一些默认设置，它们在这种情况下可能很有用。

#### [CurrentUserDefault](https://www.django-rest-framework.org/api-guide/validators/#currentuserdefault)

可用于表示当前用户的默认类。为了使用此功能，在实例化序列化程序时，必须已将“请求”作为上下文字典的一部分提供。

```python
owner = serializers.HiddenField(
    default=serializers.CurrentUserDefault()
)
```

#### [CreateOnlyDefault](https://www.django-rest-framework.org/api-guide/validators/#createonlydefault)

只能用于*在创建操作期间设置默认参数*的默认类。在更新期间，该字段被忽略。

它带有一个参数，这是在创建操作期间应使用的默认值或可调用参数。

```python
created_at = serializers.DateTimeField(
    default=serializers.CreateOnlyDefault(timezone.now)
)
```

------

# [验证者的局限性](https://www.django-rest-framework.org/api-guide/validators/#limitations-of-validators)

在某些模棱两可的情况下，您将需要显式地处理验证，而不是依赖于所`ModelSerializer`生成的默认序列化器类 。

在这些情况下，您可能需要通过为序列化程序`Meta.validators`属性指定一个空列表来禁用自动生成的验证器。

## [选填栏位](https://www.django-rest-framework.org/api-guide/validators/#optional-fields)

默认情况下，“唯一在一起”验证将强制所有字段均为 `required=True`。在某些情况下，您可能希望显式应用 `required=False`到其中一个字段，在这种情况下，所需的验证行为是不明确的。

在这种情况下，通常将需要从序列化器类中排除验证器，而是在`.validate()`方法或视图中显式编写任何验证逻辑。

例如：

```python
class BillingRecordSerializer(serializers.ModelSerializer):
    def validate(self, attrs):
        # Apply custom validation either here, or in the view.

    class Meta:
        fields = ['client', 'date', 'amount']
        extra_kwargs = {'client': {'required': False}}
        validators = []  # Remove a default "unique together" constraint.
```

## [更新嵌套的序列化器](https://www.django-rest-framework.org/api-guide/validators/#updating-nested-serializers)

将更新应用于现有实例时，唯一性验证器会将当前实例从唯一性检查中排除。当前实例在唯一性检查的上下文中可用，因为它是`instance=...`实例化序列化程序时最初使用的传递给序列化程序的属性 。

对于*嵌套*序列化程序的更新操作，由于实例不可用，因此无法应用此排除。

同样，您可能想要从序列化器类中显式删除验证器，并在`.validate()`方法或视图中显式编写验证约束的代码。

## [调试复杂案例](https://www.django-rest-framework.org/api-guide/validators/#debugging-complex-cases)

如果不确定某个`ModelSerializer`类将产生什么样的行为，通常最好运行一个`manage.py shell`，并打印一个序列化器的实例，以便您可以检查它为您自动生成的字段和验证器。

```python
>>> serializer = MyComplexModelSerializer()
>>> print(serializer)
class MyComplexModelSerializer:
    my_fields = ...
```

还请记住，在复杂的情况下，通常最好是显式定义序列化程序类，而不是依赖于默认 `ModelSerializer`行为。这涉及更多代码，但可以确保结果行为更加透明。

------

# [编写自定义验证器](https://www.django-rest-framework.org/api-guide/validators/#writing-custom-validators)

您可以使用Django现有的任何验证器，也可以编写自己的自定义验证器。

## [基于功能](https://www.django-rest-framework.org/api-guide/validators/#function-based)

验证器可以是引发`serializers.ValidationError`失败的任何可调用对象。

```python
def even_number(value):
    if value % 2 != 0:
        raise serializers.ValidationError('This field must be an even number.')
```

#### [现场级验证](https://www.django-rest-framework.org/api-guide/validators/#field-level-validation)

您可以通过向子类中添加`.validate_`方法来指定自定义字段级验证`Serializer`。这在 [Serializer文档中有记录](https://www.django-rest-framework.org/api-guide/serializers/#field-level-validation)

## [基于类](https://www.django-rest-framework.org/api-guide/validators/#class-based)

要编写基于类的验证器，请使用`__call__`方法。基于类的验证器非常有用，因为它们允许您参数化和重用行为。

```python
class MultipleOf(object):
    def __init__(self, base):
        self.base = base

    def __call__(self, value):
        if value % self.base != 0:
            message = 'This field must be a multiple of %d.' % self.base
            raise serializers.ValidationError(message)
```

#### [访问上下文](https://www.django-rest-framework.org/api-guide/validators/#accessing-the-context)

在某些高级情况下，您可能希望将验证器传递给与其他上下文一起使用的序列化器字段。您可以通过`requires_context = True`在验证器上设置属性来实现。`__call__`然后，将使用`serializer_field` 或`serializer`作为附加参数调用该方法。

```python
requires_context = True

def __call__(self, value, serializer_field):
    ...
```