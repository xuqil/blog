# [认证方式](https://www.django-rest-framework.org/api-guide/authentication/#authentication)

> Auth必须是可插入的。
>
> -Jacob Kaplan-Moss，[“ REST最坏做法”](https://jacobian.org/writing/rest-worst-practices/)

身份验证是将传入请求与一组标识凭据（例如，请求来自的用户或与其进行签名的令牌）相关联的机制。然后，[权限](https://www.django-rest-framework.org/api-guide/permissions/)和[限制](https://www.django-rest-framework.org/api-guide/throttling/)策略可以使用这些凭据来确定是否应允许该请求。

REST框架提供了许多现成的身份验证方案，并且还允许您实现自定义方案。

身份验证始终在视图的最开始，权限和限制检查发生之前以及允许任何其他代码继续执行之前运行。

该`request.user`属性通常将设置为`contrib.auth`包`User`类的实例。

该`request.auth`属性用于任何其他身份验证信息，例如，它可用于表示与请求进行签名的身份验证令牌。

------

**注意：**不要忘了**身份验证本身不会允许或不允许传入的请求**，它只会标识发出请求的凭据。

有关如何为您的API设置权限策略的信息，请参阅[权限文档](https://www.django-rest-framework.org/api-guide/permissions/)。

------

## [如何确定身份验证](https://www.django-rest-framework.org/api-guide/authentication/#how-authentication-is-determined)

身份验证方案始终定义为类列表。REST框架将尝试对列表中的每个类进行身份验证，并将设置`request.user`并`request.auth`使用成功进行身份验证的第一个类的返回值。

如果没有任何类通过身份验证，`request.user`则将设置为的实例`django.contrib.auth.models.AnonymousUser`，并将`request.auth`设置为`None`。

未认证请求的`request.user`和值`request.auth`可以使用`UNAUTHENTICATED_USER`和`UNAUTHENTICATED_TOKEN`设置进行修改。

## [设置认证方案](https://www.django-rest-framework.org/api-guide/authentication/#setting-the-authentication-scheme)

可以使用该`DEFAULT_AUTHENTICATION_CLASSES`设置全局设置默认身份验证方案。例如。

```python
REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': [
        'rest_framework.authentication.BasicAuthentication',
        'rest_framework.authentication.SessionAuthentication',
    ]
}
```

您还可以使用`APIView`基于类的视图基于每个视图或每个视图集设置身份验证方案。

```python
from rest_framework.authentication import SessionAuthentication, BasicAuthentication
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
from rest_framework.views import APIView

class ExampleView(APIView):
    authentication_classes = [SessionAuthentication, BasicAuthentication]
    permission_classes = [IsAuthenticated]

    def get(self, request, format=None):
        content = {
            'user': unicode(request.user),  # `django.contrib.auth.User` instance.
            'auth': unicode(request.auth),  # None
        }
        return Response(content)
```

或者，如果您将`@api_view`装饰器与基于函数的视图一起使用。

```python
@api_view(['GET'])
@authentication_classes([SessionAuthentication, BasicAuthentication])
@permission_classes([IsAuthenticated])
def example_view(request, format=None):
    content = {
        'user': unicode(request.user),  # `django.contrib.auth.User` instance.
        'auth': unicode(request.auth),  # None
    }
    return Response(content)
```

## [未经授权和禁止的回应](https://www.django-rest-framework.org/api-guide/authentication/#unauthorized-and-forbidden-responses)

当未经身份验证的请求被拒绝权限时，可能有两个不同的错误代码可能适用。

- [HTTP 401未经授权](https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.4.2)
- [HTTP 403权限被拒绝](https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.4.4)

HTTP 401响应必须始终包含`WWW-Authenticate`标头，该标头指示客户端如何进行身份验证。HTTP 403响应不包含`WWW-Authenticate`标头。

将使用的响应类型取决于身份验证方案。尽管可以使用多种身份验证方案，但仅可以使用一种方案来确定响应的类型。 **确定响应类型时，将使用在视图上设置的第一个身份验证类**。

请注意，当请求可以成功进行身份验证但仍然被拒绝执行该请求的权限时`403 Permission Denied`，无论身份验证方案如何，都将始终使用响应。

## [Apache mod_wsgi特定配置](https://www.django-rest-framework.org/api-guide/authentication/#apache-mod_wsgi-specific-configuration)

请注意，如果[使用mod_wsgi](https://modwsgi.readthedocs.io/en/develop/configuration-directives/WSGIPassAuthorization.html)部署到[Apache](https://modwsgi.readthedocs.io/en/develop/configuration-directives/WSGIPassAuthorization.html)，则默认情况下不会将授权标头传递给WSGI应用程序，因为假定身份验证将由Apache处理，而不是在应用程序级别进行。

如果要部署到Apache并使用任何基于非会话的身份验证，则需要显式配置mod_wsgi以将所需的标头传递给应用程序。这可以通过`WSGIPassAuthorization`在适当的上下文中指定指令并将其设置为来完成`'On'`。

```python
# this can go in either server config, virtual host, directory or .htaccess
WSGIPassAuthorization On
```

------

# [API参考](https://www.django-rest-framework.org/api-guide/authentication/#api-reference)

## [基本认证](https://www.django-rest-framework.org/api-guide/authentication/#basicauthentication)

此身份验证方案使用[HTTP基本身份验证](https://tools.ietf.org/html/rfc2617)，该身份针对用户的用户名和密码进行了签名。基本身份验证通常仅适用于测试。

如果成功通过身份验证，请`BasicAuthentication`提供以下凭据。

- `request.user`将是Django `User`实例。
- `request.auth`将会`None`。

未经授权的未经身份验证的响应将被拒绝，`HTTP 401 Unauthorized`并带有适当的WWW-Authenticate标头。例如：

```python
WWW-Authenticate: Basic realm="api"
```

**注意：**如果用于`BasicAuthentication`生产环境，则必须确保您的API仅可用于`https`。您还应确保您的API客户端始终在登录时重新请求用户名和密码，并且永远不会将这些详细信息存储到持久性存储中。

## [令牌认证](https://www.django-rest-framework.org/api-guide/authentication/#tokenauthentication)

此身份验证方案使用简单的基于令牌的HTTP身份验证方案。令牌认证适用于客户端-服务器设置，例如本机台式机和移动客户端。

要使用该`TokenAuthentication`方案，您需要[将身份验证类配置](https://www.django-rest-framework.org/api-guide/authentication/#setting-the-authentication-scheme)为include `TokenAuthentication`，并另外`rest_framework.authtoken`在您的`INSTALLED_APPS`设置中包括：

```python
INSTALLED_APPS = [
    ...
    'rest_framework.authtoken'
]
```

------

**注意：**请确保`manage.py migrate`在更改设置后运行。该`rest_framework.authtoken`应用程序提供Django数据库迁移。

------

您还需要为用户创建令牌。

```python
from rest_framework.authtoken.models import Token

token = Token.objects.create(user=...)
print(token.key)
```

为了使客户端进行身份验证，令牌密钥应包含在`Authorization`HTTP标头中。密钥应以字符串文字“ Token”作为前缀，并用空格分隔两个字符串。例如：

```python
Authorization: Token 9944b09199c62bcf9418ad846dd0e4bbdfc6ee4b
```

**注意：**如果要在标头中使用其他关键字，例如`Bearer`，只需将其子类化`TokenAuthentication`并设置`keyword`类变量即可。

如果成功通过身份验证，请`TokenAuthentication`提供以下凭据。

- `request.user`将是Django `User`实例。
- `request.auth`将是一个`rest_framework.authtoken.models.Token`实例。

未经授权的未经身份验证的响应将被拒绝，`HTTP 401 Unauthorized`并带有适当的WWW-Authenticate标头。例如：

```python
WWW-Authenticate: Token
```

该`curl`命令行工具可以用于测试令牌身份验证的API是有用的。例如：

```python
curl -X GET http://127.0.0.1:8000/api/example/ -H 'Authorization: Token 9944b09199c62bcf9418ad846dd0e4bbdfc6ee4b'
```

------

**注意：**如果用于`TokenAuthentication`生产环境，则必须确保您的API仅可用于`https`。

------

#### [生成令牌](https://www.django-rest-framework.org/api-guide/authentication/#generating-tokens)

##### [通过使用信号](https://www.django-rest-framework.org/api-guide/authentication/#by-using-signals)

如果希望每个用户都有一个自动生成的令牌，则只需捕获用户的`post_save`信号即可。

```python
from django.conf import settings
from django.db.models.signals import post_save
from django.dispatch import receiver
from rest_framework.authtoken.models import Token

@receiver(post_save, sender=settings.AUTH_USER_MODEL)
def create_auth_token(sender, instance=None, created=False, **kwargs):
    if created:
        Token.objects.create(user=instance)
```

请注意，您将要确保将此代码段放置在已安装的`models.py`模块中，或将在启动时由Django导入的其他位置。

如果已经创建了一些用户，则可以为所有现有用户生成令牌，如下所示：

```python
from django.contrib.auth.models import User
from rest_framework.authtoken.models import Token

for user in User.objects.all():
    Token.objects.get_or_create(user=user)
```

##### [通过公开api端点](https://www.django-rest-framework.org/api-guide/authentication/#by-exposing-an-api-endpoint)

使用时`TokenAuthentication`，您可能希望为客户端提供一种机制，以给定用户名和密码来获得令牌。REST框架提供了一个内置视图来提供此行为。要使用它，请将`obtain_auth_token`视图添加到您的URLconf中：

```python
from rest_framework.authtoken import views
urlpatterns += [
    url(r'^api-token-auth/', views.obtain_auth_token)
]
```

请注意，模式的URL部分可以是您要使用的任何内容。

`obtain_auth_token`当有效`username`且`password`使用表单数据或JSON将字段发布到视图时，视图将返回JSON响应：

```python
{ 'token' : '9944b09199c62bcf9418ad846dd0e4bbdfc6ee4b' }
```

请注意，默认`obtain_auth_token`视图明确使用JSON请求和响应，而不是在设置中使用默认渲染器和解析器类。

默认情况下，没有权限或限制应用于 `obtain_auth_token`视图。如果您希望应用限制，则需要重写视图类，并使用`throttle_classes`属性将其包括在内。

如果您需要`obtain_auth_token`视图的自定义版本，则可以通过将`ObtainAuthToken`视图类子类化，然后在url conf中使用它来实现。

例如，您可以返回`token`值以外的其他用户信息：

```python
from rest_framework.authtoken.views import ObtainAuthToken
from rest_framework.authtoken.models import Token
from rest_framework.response import Response

class CustomAuthToken(ObtainAuthToken):

    def post(self, request, *args, **kwargs):
        serializer = self.serializer_class(data=request.data,
                                           context={'request': request})
        serializer.is_valid(raise_exception=True)
        user = serializer.validated_data['user']
        token, created = Token.objects.get_or_create(user=user)
        return Response({
            'token': token.key,
            'user_id': user.pk,
            'email': user.email
        })
```

并在您的`urls.py`：

```python
urlpatterns += [
    url(r'^api-token-auth/', CustomAuthToken.as_view())
]
```

##### [使用Django admin](https://www.django-rest-framework.org/api-guide/authentication/#with-django-admin)

也可以通过管理界面手动创建令牌。如果您使用的是庞大的用户群，建议您猴子修补`TokenAdmin`该类以根据需要对其进行自定义，更具体地讲，将`user`字段声明为`raw_field`。

`your_app/admin.py`：

```python
from rest_framework.authtoken.admin import TokenAdmin

TokenAdmin.raw_id_fields = ['user']
```

#### [使用Django manage.py命令](https://www.django-rest-framework.org/api-guide/authentication/#using-django-managepy-command)

从3.6.4版开始，可以使用以下命令生成用户令牌：

```python
./manage.py drf_create_token <username>
```

此命令将返回给定用户的API令牌，如果不存在则创建它：

```python
Generated token 9944b09199c62bcf9418ad846dd0e4bbdfc6ee4b for user user1
```

如果您想重新生成令牌（例如，如果它已被破坏或泄漏），则可以传递一个附加参数：

```python
./manage.py drf_create_token -r <username>
```

## [会话认证](https://www.django-rest-framework.org/api-guide/authentication/#sessionauthentication)

此身份验证方案使用Django的默认会话后端进行身份验证。会话身份验证适用于在与您的网站相同的会话上下文中运行的AJAX客户端。

如果成功通过身份验证，请`SessionAuthentication`提供以下凭据。

- `request.user`将是Django `User`实例。
- `request.auth`将会`None`。

未经授权的未经身份验证的响应将被拒绝`HTTP 403 Forbidden`。

如果您使用的是AJAX风格的API与SessionAuthentication，你需要确保你的令牌包含任何“不安全”的HTTP方法调用一个有效的CSRF，如`PUT`，`PATCH`，`POST`或`DELETE`请求。有关更多详细信息，请参见[Django CSRF文档](https://docs.djangoproject.com/en/stable/ref/csrf/#ajax)。

**警告**：创建登录页面时，请始终使用Django的标准登录视图。这将确保您的登录视图受到适当的保护。

REST框架中的CSRF验证与标准Django的工作原理略有不同，这是因为需要对同一视图同时支持基于会话和基于非会话的身份验证。这意味着只有经过身份验证的请求才需要CSRF令牌，而匿名请求可能没有CSRF令牌就可以发送。此行为不适用于应始终应用CSRF验证的登录视图。

## [远程用户认证](https://www.django-rest-framework.org/api-guide/authentication/#remoteuserauthentication)

通过此身份验证方案，您可以将身份验证委派给Web服务器，该服务器设置`REMOTE_USER` 环境变量。

要使用它，您的设置中必须具有`django.contrib.auth.backends.RemoteUserBackend`（或子类） `AUTHENTICATION_BACKENDS`。默认情况下，为尚不存在的用户名`RemoteUserBackend`创建`User`对象。要更改此行为和其他行为，请参阅 [Django文档](https://docs.djangoproject.com/en/stable/howto/auth-remote-user/)。

如果成功通过身份验证，请`RemoteUserAuthentication`提供以下凭据：

- `request.user`将是Django `User`实例。
- `request.auth`将会`None`。

有关配置身份验证方法的信息，请查阅Web服务器的文档，例如：

- [Apache身份验证方法](https://httpd.apache.org/docs/2.4/howto/auth.html)
- [NGINX（限制访问）](https://www.nginx.com/resources/admin-guide/#restricting_access)

# [自定义身份验证](https://www.django-rest-framework.org/api-guide/authentication/#custom-authentication)

要实现自定义身份验证方案，请子类化`BaseAuthentication`并重写该`.authenticate(self, request)`方法。`(user, auth)`如果身份验证成功，则该方法应返回两个元组`None`。

在某些情况下`None`，您可能想`AuthenticationFailed`从`.authenticate()`方法中引发异常，而不是返回。

通常，您应该采用的方法是：

- 如果未尝试认证，请返回`None`。还在使用的任何其他身份验证方案仍将被检查。
- 如果尝试进行身份验证但失败，请引发`AuthenticationFailed`异常。不管是否进行任何权限检查，并且不检查任何其他身份验证方案，都将立即返回错误响应。

您*也*可以覆盖该`.authenticate_header(self, request)`方法。如果实现，则应返回一个字符串，该字符串将用作响应`WWW-Authenticate`中标头的值`HTTP 401 Unauthorized`。

如果`.authenticate_header()`未重写该方法，则`HTTP 403 Forbidden`当未认证的请求被拒绝访问时，认证方案将返回响应。

------

**注意：**当您的自定义身份验证器由请求对象的`.user`或`.auth`属性调用时，您可能会看到`AttributeError`重新引发为`WrappedAttributeError`。这对于防止原始异常被外部属性访问抑制是必要的。Python不会识别出`AttributeError`起源于您的自定义身份验证器，而是会假设请求对象没有`.user`或`.auth`属性。这些错误应由验证者修复或以其他方式处理。

------

## [例](https://www.django-rest-framework.org/api-guide/authentication/#example)

以下示例将对名为“ X-USERNAME”的自定义请求标头中的用户名指定的用户身份进行身份验证。

```python
from django.contrib.auth.models import User
from rest_framework import authentication
from rest_framework import exceptions

class ExampleAuthentication(authentication.BaseAuthentication):
    def authenticate(self, request):
        username = request.META.get('HTTP_X_USERNAME')
        if not username:
            return None

        try:
            user = User.objects.get(username=username)
        except User.DoesNotExist:
            raise exceptions.AuthenticationFailed('No such user')

        return (user, None)
```

------

# [第三方套餐](https://www.django-rest-framework.org/api-guide/authentication/#third-party-packages)

以下第三方软件包也可用。

## [Django OAuth工具包](https://www.django-rest-framework.org/api-guide/authentication/#django-oauth-toolkit)

在[Django的OAuth的工具包](https://github.com/evonove/django-oauth-toolkit)包提供的OAuth 2.0的支持，并与Python 3.4+工作。该软件包由[Evonove](https://github.com/evonove/)维护，并使用出色的[OAuthLib](https://github.com/idan/oauthlib)。该软件包有充分的文档记录和良好的支持，并且目前是我们**推荐用于OAuth 2.0支持的软件包**。

#### [安装与配置](https://www.django-rest-framework.org/api-guide/authentication/#installation-configuration)

使用安装`pip`。

```python
pip install django-oauth-toolkit
```

将软件包添加到您的文件中，`INSTALLED_APPS`然后修改您的REST框架设置。

```python
INSTALLED_APPS = [
    ...
    'oauth2_provider',
]

REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': [
        'oauth2_provider.contrib.rest_framework.OAuth2Authentication',
    ]
}
```

有关更多详细信息，请参见[Django REST框架-入门](https://django-oauth-toolkit.readthedocs.io/en/latest/rest-framework/getting_started.html)文档。

## [Django REST框架OAuth](https://www.django-rest-framework.org/api-guide/authentication/#django-rest-framework-oauth)

在[Django的REST框架的OAuth](https://jpadilla.github.io/django-rest-framework-oauth/)包提供了REST框架都您好！OAuth1和OAuth2支援。

该程序包以前直接包含在REST框架中，但现在作为第三方程序包得到支持和维护。

#### [安装与配置](https://www.django-rest-framework.org/api-guide/authentication/#installation-configuration_1)

使用安装软件包`pip`。

```
pip install djangorestframework-oauth
```

有关配置和用法的详细信息，请参阅Django REST框架OAuth文档以获取[身份验证](https://jpadilla.github.io/django-rest-framework-oauth/authentication/)和[权限](https://jpadilla.github.io/django-rest-framework-oauth/permissions/)。

## [JSON Web令牌认证](https://www.django-rest-framework.org/api-guide/authentication/#json-web-token-authentication)

JSON Web令牌是一个相当新的标准，可用于基于令牌的身份验证。与内置的TokenAuthentication方案不同，JWT Authentication不需要使用数据库来验证令牌。用于JWT身份验证的软件包是[djangorestframework-simplejwt](https://github.com/davesque/django-rest-framework-simplejwt)，它提供了一些功能以及可插入的令牌黑名单应用程序。

## [Hawk HTTP验证](https://www.django-rest-framework.org/api-guide/authentication/#hawk-http-authentication)

该[HawkREST](https://hawkrest.readthedocs.io/en/latest/)库建立在[莫霍克](https://mohawk.readthedocs.io/en/latest/)库，让你的工作与[鹰](https://github.com/hueniverse/hawk)签署您的API请求和响应。[Hawk](https://github.com/hueniverse/hawk)使两方可以使用共享密钥签名的消息彼此安全地通信。它基于[HTTP MAC访问身份验证](https://tools.ietf.org/html/draft-hammer-oauth-v2-mac-token-05)（基于[OAuth 1.0的](https://oauth.net/core/1.0a/)某些部分）。

## [HTTP签名认证](https://www.django-rest-framework.org/api-guide/authentication/#http-signature-authentication)

HTTP签名（当前为[IETF草案](https://datatracker.ietf.org/doc/draft-cavage-http-signatures/)）提供了一种实现HTTP消息的原始身份验证和消息完整性的方法。与许多服务使用的[亚马逊的HTTP签名方案](https://docs.aws.amazon.com/general/latest/gr/signature-version-4.html)类似，它允许无状态的按请求身份验证。[Elvio Toccalino](https://github.com/etoccalino/)维护[djangorestframework-httpsignature](https://github.com/etoccalino/django-rest-framework-httpsignature)（已过时）软件包，该软件包提供了易于使用的HTTP签名身份验证机制。您可以使用[djangorestframework-httpsignature](https://github.com/etoccalino/django-rest-framework-httpsignature)的更新的fork版本，即[drf-httpsig](https://github.com/ahknight/drf-httpsig)。

## [乔瑟](https://www.django-rest-framework.org/api-guide/authentication/#djoser)

[Djoser](https://github.com/sunscrapers/djoser)库提供了一组视图来处理基本操作，例如注册，登录，注销，密码重置和帐户激活。该软件包与自定义用户模型一起使用，并且使用基于令牌的身份验证。这是一个随时可以使用的Django身份验证系统的REST实现。

## [django-rest-auth](https://www.django-rest-framework.org/api-guide/authentication/#django-rest-auth)

[Django-rest-auth](https://github.com/Tivix/django-rest-auth)库提供了一组REST API端点，用于注册，身份验证（包括社交媒体身份验证），密码重置，检索和更新用户详细信息等。通过拥有这些API端点，您的客户端应用（例如AngularJS，iOS， Android和其他操作系统可以通过REST API单独与您的Django后端站点进行通信，以进行用户管理。

## [django-rest-framework-social-oauth2](https://www.django-rest-framework.org/api-guide/authentication/#django-rest-framework-social-oauth2)

[Django-rest-framework-social-oauth2](https://github.com/PhilipGarnero/django-rest-framework-social-oauth2)库提供了一种将社交插件（facebook，twitter，google等）集成到身份验证系统的简便方法，并提供了简单的oauth2设置。使用此库，您将能够基于外部令牌（例如，Facebook访问令牌）对用户进行身份验证，将这些令牌转换为“内部” oauth2令牌，并使用并生成oauth2令牌来对用户进行身份验证。

## [django-rest-knox](https://www.django-rest-framework.org/api-guide/authentication/#django-rest-knox)

[Django-rest-knox](https://github.com/James1345/django-rest-knox)库提供的模型和视图以比内置TokenAuthentication方案更安全和可扩展的方式处理基于令牌的身份验证-考虑到单页应用程序和移动客户端。它提供了每个客户端令牌，并提供了一些其他身份验证（通常是基本身份验证）以生成令牌，删除令牌（提供服务器强制注销）和删除所有令牌（注销用户已登录的所有客户端）的视图。 ）。

## [drfpasswordless](https://www.django-rest-framework.org/api-guide/authentication/#drfpasswordless)

[drfpasswordless](https://github.com/aaronn/django-rest-framework-passwordless)为Django REST Framework自己的TokenAuthentication方案增加了（无中号，Square Cash启发）无密码支持。用户登录并使用发送到联系点（如电子邮件地址或手机号码）的令牌进行注册。