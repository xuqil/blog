# [权限](https://www.django-rest-framework.org/api-guide/permissions/#permissions)

> 通常，仅进行身份验证或标识不足以获取信息或代码。为此，请求访问的实体必须具有授权。
>
> — [Apple开发人员文档](https://developer.apple.com/library/mac/#documentation/security/Conceptual/AuthenticationAndAuthorizationGuide/Authorization/Authorization.html)

权限与[身份验证](https://www.django-rest-framework.org/api-guide/authentication/)和[限制](https://www.django-rest-framework.org/api-guide/throttling/)一起，决定了是否应授予请求访问权限。

权限检查始终在视图的最开始处运行，然后再允许执行其他任何代码。权限检查通常会使用`request.user`和`request.auth`属性中的身份验证信息来确定是否应允许传入请求。

权限用于授予或拒绝不同类别的用户对API不同部分的访问。

最简单的许可方式是允许访问任何经过身份验证的用户，并拒绝访问任何未经身份验证的用户。这对应`IsAuthenticated`于REST框架中的类。

稍微不太严格的权限样式将是允许对经过身份验证的用户进行完全访问，但允许对未经身份验证的用户进行只读访问。这对应`IsAuthenticatedOrReadOnly`于REST框架中的类。

## [如何确定权限](https://www.django-rest-framework.org/api-guide/permissions/#how-permissions-are-determined)

REST框架中的权限始终定义为权限类列表。

在运行视图主体之前，将检查列表中的每个权限。如果任何权限检查失败，则将引发`exceptions.PermissionDenied`或`exceptions.NotAuthenticated`异常，并且视图主体将不运行。

当权限检查失败时，将根据以下规则返回“ 403禁止访问”或“ 401未经授权”响应：

- 该请求已成功通过身份验证，但权限被拒绝。*—将返回HTTP 403禁止响应。*
- 该请求未成功通过身份验证，并且最高优先级的身份验证类*不*使用`WWW-Authenticate`标头。*—将返回HTTP 403禁止响应。*
- 该请求未成功通过身份验证，并且最高优先级的身份验证类*确实*使用`WWW-Authenticate`标头。*— `WWW-Authenticate`将返回带有适当标头的HTTP 401未经授权的响应。*

## [对象级别权限](https://www.django-rest-framework.org/api-guide/permissions/#object-level-permissions)

REST框架权限还支持对象级权限。对象级别权限用于确定是否应允许用户对特定对象执行操作，该对象通常是模型实例。

`.get_object()`调用时，对象级别权限由REST框架的通用视图运行。与视图级别权限一样，`exceptions.PermissionDenied`如果不允许用户对给定对象执行操作，则会引发异常。

如果您要编写自己的视图并要强制执行对象级别权限，或者`get_object`在通用视图上覆盖该方法，则需要`.check_object_permissions(request, obj)`在检索到该位置的视图上显式调用该方法。宾语。

这将引发`PermissionDenied`或`NotAuthenticated`异常，或者如果视图具有适当的权限则仅返回。

例如：

```python
def get_object(self):
    obj = get_object_or_404(self.get_queryset(), pk=self.kwargs["pk"])
    self.check_object_permissions(self.request, obj)
    return obj
```

------

**注意**：除了之外`DjangoObjectPermissions`，中提供的权限类`rest_framework.permissions` **未**实现检查对象权限所必需的方法。

如果希望使用提供的权限类来检查对象权限，则**必须对**它们进行子类化并实现`has_object_permission()`“ [*自定义权限”*](https://www.django-rest-framework.org/api-guide/permissions/#custom-permissions)部分（如下所示）中所述的 方法。

------

#### [对象级别权限的限制](https://www.django-rest-framework.org/api-guide/permissions/#limitations-of-object-level-permissions)

出于性能原因，返回对象列表时，通用视图不会自动将对象级别权限应用于查询集中的每个实例。

通常，当您使用对象级别权限时，您还希望适当地[过滤查询集](https://www.django-rest-framework.org/api-guide/filtering/)，以确保用户仅能查看允许其查看的实例。

## [设置权限策略](https://www.django-rest-framework.org/api-guide/permissions/#setting-the-permission-policy)

可以使用该`DEFAULT_PERMISSION_CLASSES`设置在全局范围内设置默认权限策略。例如。

```python
REST_FRAMEWORK = {
    'DEFAULT_PERMISSION_CLASSES': [
        'rest_framework.permissions.IsAuthenticated',
    ]
}
```

如果未指定，则此设置默认为允许无限制访问：

```python
'DEFAULT_PERMISSION_CLASSES': [
   'rest_framework.permissions.AllowAny',
]
```

您还可以使用`APIView`基于类的视图基于每个视图或每个视图集设置身份验证策略。

```python
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
from rest_framework.views import APIView

class ExampleView(APIView):
    permission_classes = [IsAuthenticated]

    def get(self, request, format=None):
        content = {
            'status': 'request was permitted'
        }
        return Response(content)
```

或者，如果您将`@api_view`装饰器与基于函数的视图一起使用。

```python
from rest_framework.decorators import api_view, permission_classes
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response

@api_view(['GET'])
@permission_classes([IsAuthenticated])
def example_view(request, format=None):
    content = {
        'status': 'request was permitted'
    }
    return Response(content)
```

**注意：**当您通过class属性或装饰器设置新的权限类时，您是在告诉视图忽略**settings.py**文件上**设置**的默认列表。

如果它们继承自`rest_framework.permissions.BasePermission`，则可以使用标准的Python按位运算符来组合权限。例如，`IsAuthenticatedOrReadOnly`可以这样写：

```python
from rest_framework.permissions import BasePermission, IsAuthenticated, SAFE_METHODS
from rest_framework.response import Response
from rest_framework.views import APIView

class ReadOnly(BasePermission):
    def has_permission(self, request, view):
        return request.method in SAFE_METHODS

class ExampleView(APIView):
    permission_classes = [IsAuthenticated|ReadOnly]

    def get(self, request, format=None):
        content = {
            'status': 'request was permitted'
        }
        return Response(content)
```

**注意：**它支持＆（和），|。（或）和〜（不是）。

------

# [API参考](https://www.django-rest-framework.org/api-guide/permissions/#api-reference)

## [允许](https://www.django-rest-framework.org/api-guide/permissions/#allowany)

该`AllowAny`许可类将允许不受限制的访问，**不管请求被认证或未认证的**。

此权限不是严格要求的，因为您可以通过将空列表或元组用于权限设置来达到相同的结果，但是您可以发现指定该类很有用，因为它使意图明确。

## [已认证](https://www.django-rest-framework.org/api-guide/permissions/#isauthenticated)

该`IsAuthenticated`许可类将拒绝允许任何未认证用户，并允许许可，否则。

如果您希望仅注册用户可以访问您的API，则此权限很合适。

## [IsAdminUser](https://www.django-rest-framework.org/api-guide/permissions/#isadminuser)

所述`IsAdminUser`许可类将拒绝许可给任何用户，除非`user.is_staff`是`True`在这种情况下的许可将被允许。

如果只希望一部分受信任的管理员可以访问您的API，则此权限很合适。

## [IsAuthenticatedOrReadOnly](https://www.django-rest-framework.org/api-guide/permissions/#isauthenticatedorreadonly)

在`IsAuthenticatedOrReadOnly`将允许被授权的用户进行任何请求。仅当请求方法是“安全”方法之一时，才允许对未授权用户的请求；`GET`，`HEAD`或`OPTIONS`。

如果您希望您的API允许匿名用户具有读取权限，而只允许经过身份验证的用户具有写入权限，则此权限非常适合。

## [DjangoModelPermissions](https://www.django-rest-framework.org/api-guide/permissions/#djangomodelpermissions)

该权限类与Django的标准`django.contrib.auth` [模型权限相关](https://docs.djangoproject.com/en/stable/topics/auth/customizing/#custom-permissions)。此权限只能应用于`.queryset`设置了属性的视图。只有在对用户*进行身份验证*并分配了*相关模型权限的情况下，*才可以授予授权。

- `POST`请求需要用户对`add`模型具有权限。
- `PUT`并且`PATCH`请求要求用户对`change`模型具有权限。
- `DELETE`请求需要用户对`delete`模型具有权限。

也可以覆盖默认行为以支持自定义模型权限。例如，您可能要包括请求的`view`模型权限`GET`。

要使用自定义模型权限，请覆盖`DjangoModelPermissions`并设置`.perms_map`属性。有关详细信息，请参考源代码。

#### [与不包含`queryset`属性的视图一起使用。](https://www.django-rest-framework.org/api-guide/permissions/#using-with-views-that-do-not-include-a-queryset-attribute)

如果您将此权限与使用重写`get_queryset()`方法的视图一起使用，则该视图上可能没有`queryset`属性。在这种情况下，我们建议您还使用哨兵查询集标记视图，以便此类可以确定所需的权限。例如：

```python
queryset = User.objects.none()  # Required for DjangoModelPermissions
```

## [DjangoModelPermissionsOrAnonReadOnly](https://www.django-rest-framework.org/api-guide/permissions/#djangomodelpermissionsoranonreadonly)

与相似`DjangoModelPermissions`，但也允许未经身份验证的用户具有对API的只读访问权限。

## [DjangoObjectPermissions](https://www.django-rest-framework.org/api-guide/permissions/#djangoobjectpermissions)

该权限类与Django的标准[对象权限框架相关联](https://docs.djangoproject.com/en/stable/topics/auth/customizing/#handling-object-permissions)，该[框架](https://docs.djangoproject.com/en/stable/topics/auth/customizing/#handling-object-permissions)允许对模型进行按对象的权限。为了使用此权限类，您还需要添加一个支持对象级权限的权限后端，例如[django-guardian](https://github.com/lukaszb/django-guardian)。

与一样`DjangoModelPermissions`，此权限必须仅应用于具有`.queryset`属性或`.get_queryset()`方法的视图。仅当用户*通过身份验证*并分配了*相关的每个对象权限*和*相关的模型权限后，*才会授予授权。

- `POST`请求要求用户对`add`模型实例具有权限。
- `PUT`并且`PATCH`请求要求用户对`change`模型实例具有权限。
- `DELETE`请求要求用户对`delete`模型实例具有权限。

请注意，`DjangoObjectPermissions` **它**不需要`django-guardian`软件包，并且应该同样支持其他对象级后端。

与`DjangoModelPermissions`您一样，您可以通过覆盖`DjangoObjectPermissions`和设置`.perms_map`属性来使用自定义模型权限。有关详细信息，请参考源代码。

------

**注意**：如果您需要和的对象级`view`权限`GET`，`HEAD`并且`OPTIONS`正在使用django-guardian作为对象级权限后端，则需要考虑使用[package](https://github.com/rpkilby/django-rest-framework-guardian)`DjangoObjectPermissionsFilter`提供的类。它确保列表端点仅返回结果，包括用户具有相应查看权限的对象。[`djangorestframework-guardian`](https://github.com/rpkilby/django-rest-framework-guardian)

------

# [自定义权限](https://www.django-rest-framework.org/api-guide/permissions/#custom-permissions)

要实现自定义权限，请重写`BasePermission`并实现以下方法之一或两者：

- `.has_permission(self, request, view)`
- `.has_object_permission(self, request, view, obj)`

`True`如果应授予请求访问权，则方法应返回，`False`否则返回。

如果你需要测试，如果一个请求是读操作或写操作，你应该检查对常量的请求方法`SAFE_METHODS`，这是一个包含一个元组`'GET'`，`'OPTIONS'`和`'HEAD'`。例如：

```python
if request.method in permissions.SAFE_METHODS:
    # Check permissions for read-only request
else:
    # Check permissions for write request
```

------

**注意**：`has_object_permission`仅在视图级别`has_permission`检查已经通过的情况下，才调用实例级别的方法。还要注意，为了运行实例级检查，视图代码应显式调用`.check_object_permissions(request, obj)`。如果您使用的是通用视图，则默认情况下会为您处理。（基于功能的视图将需要显式检查对象权限，从而`PermissionDenied`导致失败。）

------

`PermissionDenied`如果测试失败，则自定义权限将引发异常。要更改与异常关联的错误消息，请`message`直接在您的自定义权限上实现属性。否则`default_detail`，`PermissionDenied`将使用from属性。

```python
from rest_framework import permissions

class CustomerAccessPermission(permissions.BasePermission):
    message = 'Adding customers not allowed.'

    def has_permission(self, request, view):
         ...
```

## [例子](https://www.django-rest-framework.org/api-guide/permissions/#examples)

以下是权限类的示例，该权限类针对黑名单检查传入请求的IP地址，如果IP已被列入黑名单，则拒绝该请求。

```python
from rest_framework import permissions

class BlacklistPermission(permissions.BasePermission):
    """
    Global permission check for blacklisted IPs.
    """

    def has_permission(self, request, view):
        ip_addr = request.META['REMOTE_ADDR']
        blacklisted = Blacklist.objects.filter(ip_addr=ip_addr).exists()
        return not blacklisted
```

除了针对所有传入请求运行的全局权限外，您还可以创建仅针对影响特定对象实例的操作运行的对象级别权限。例如：

```python
class IsOwnerOrReadOnly(permissions.BasePermission):
    """
    Object-level permission to only allow owners of an object to edit it.
    Assumes the model instance has an `owner` attribute.
    """

    def has_object_permission(self, request, view, obj):
        # Read permissions are allowed to any request,
        # so we'll always allow GET, HEAD or OPTIONS requests.
        if request.method in permissions.SAFE_METHODS:
            return True

        # Instance must have an attribute named `owner`.
        return obj.owner == request.user
```

请注意，通用视图将检查适当的对象级别权限，但是，如果要编写自己的自定义视图，则需要确保自己检查对象级别权限。您可以通过`self.check_object_permissions(request, obj)`在拥有对象实例后从视图中调用来做到这一点。`APIException`如果任何对象级权限检查失败，则此调用将引发适当的调用，否则将简单地返回。

还要注意，通用视图将仅检查对象级权限以获取检索单个模型实例的视图。如果需要列表视图的对象级过滤，则需要分别过滤查询集。有关更多详细信息，请参见[过滤文档](https://www.django-rest-framework.org/api-guide/filtering/)。

------

# [第三方套餐](https://www.django-rest-framework.org/api-guide/permissions/#third-party-packages)

以下第三方软件包也可用。

## [DRF-访问策略](https://www.django-rest-framework.org/api-guide/permissions/#drf-access-policy)

在[Django的REST -访问策略](https://github.com/rsinger86/drf-access-policy)包提供了一种方式，附加到查看设置或基于函数的观点陈述策略类定义复杂的访问规则。这些策略以JSON格式定义，格式类似于AWS的身份和访问管理策略。

## [撰写的权限](https://www.django-rest-framework.org/api-guide/permissions/#composed-permissions)

的[组成权限](https://github.com/niwibe/djangorestframework-composed-permissions)包提供了一种简单的方式来定义复杂和多深度（与逻辑运算符）权限对象，使用小的和可重复使用的部件。

## [REST条件](https://www.django-rest-framework.org/api-guide/permissions/#rest-condition)

在[静止状态下](https://github.com/caxap/rest_condition)包装的另一个扩展简单和方便的方式构建复杂的权限。该扩展允许您将权限与逻辑运算符结合在一起。

## [干燥休息许可](https://www.django-rest-framework.org/api-guide/permissions/#dry-rest-permissions)

该[DRY休息权限](https://github.com/Helioscene/dry-rest-permissions)包提供定义单个默认和自定义操作不同的权限的能力。此程序包是为具有从应用程序数据模型中定义的关系派生的权限的应用程序制作的。它还支持通过API的序列化程序将权限检查返回给客户端应用。此外，它还支持向默认和自定义列表操作添加权限，以限制他们为每个用户检索的数据。

## [Django Rest框架角色](https://www.django-rest-framework.org/api-guide/permissions/#django-rest-framework-roles)

在[Django的REST框架角色](https://github.com/computer-lab/django-rest-framework-roles)包使得它更容易在多个类型的用户参数的API。

## [Django REST框架API密钥](https://www.django-rest-framework.org/api-guide/permissions/#django-rest-framework-api-key)

在[Django的REST框架API密钥](https://florimondmanca.github.io/djangorestframework-api-key/)包提供许可类，模型和助手API密钥授权添加到您的API。它可以用于授权没有用户帐户的内部或第三方后端和服务（即*计算机*）。API密钥使用Django的密码哈希基础结构安全地存储，并且可以随时在Django管理员中查看，编辑和吊销它们。

## [Django Rest框架角色过滤器](https://www.django-rest-framework.org/api-guide/permissions/#django-rest-framework-role-filters)

的[Django的休息框架中的作用的过滤器](https://github.com/allisson/django-rest-framework-role-filters)包提供在多个类型的角色简单滤波。