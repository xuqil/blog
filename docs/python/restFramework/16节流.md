# [节流](https://www.django-rest-framework.org/api-guide/throttling/#throttling)

> HTTP / 1.1 420增强镇静
>
> [Twitter API速率限制响应](https://developer.twitter.com/en/docs/basics/rate-limiting)

节流类似于[权限](https://www.django-rest-framework.org/api-guide/permissions/)，它确定是否应授权请求。节流指示临时状态，并用于控制客户端可以向API发出的请求的速率。

与权限一样，可以使用多个调节器。您的API可能会对未经身份验证的请求进行限制，而对于经过身份验证的请求则进行限制较少。

您可能要使用多个调节器的另一种情况是，由于某些服务特别耗费资源，因此您需要在API的不同部分施加不同的约束。

如果要同时施加突发节流率和持续节流率，也可以使用多个节气门。例如，您可能希望将用户限制为每分钟最多60个请求，每天最多1000个请求。

节流阀不一定仅指速率限制请求。例如，存储服务可能还需要限制带宽，而付费数据服务可能需要限制一定数量的正在访问的记录。

## [节流如何确定](https://www.django-rest-framework.org/api-guide/throttling/#how-throttling-is-determined)

与权限和身份验证一样，REST框架中的限制始终定义为类列表。

在运行视图主体之前，请检查列表中的每个油门。如果任何油门检查失败，`exceptions.Throttled`将引发异常，并且视图主体将不运行。

## [设定节流政策](https://www.django-rest-framework.org/api-guide/throttling/#setting-the-throttling-policy)

可以使用`DEFAULT_THROTTLE_CLASSES`和`DEFAULT_THROTTLE_RATES`设置全局设置默认的限制策略。例如。

```python
REST_FRAMEWORK = {
    'DEFAULT_THROTTLE_CLASSES': [
        'rest_framework.throttling.AnonRateThrottle',
        'rest_framework.throttling.UserRateThrottle'
    ],
    'DEFAULT_THROTTLE_RATES': {
        'anon': '100/day',
        'user': '1000/day'
    }
}
```

中所用的速率的描述`DEFAULT_THROTTLE_RATES`可以包括`second`，`minute`，`hour`或`day`作为节流段。

您还可以使用`APIView`基于类的视图基于每个视图或每个视图集设置节流策略。

```python
from rest_framework.response import Response
from rest_framework.throttling import UserRateThrottle
from rest_framework.views import APIView

class ExampleView(APIView):
    throttle_classes = [UserRateThrottle]

    def get(self, request, format=None):
        content = {
            'status': 'request was permitted'
        }
        return Response(content)
```

或者，如果您将`@api_view`装饰器与基于函数的视图一起使用。

```python
@api_view(['GET'])
@throttle_classes([UserRateThrottle])
def example_view(request, format=None):
    content = {
        'status': 'request was permitted'
    }
    return Response(content)
```

## [如何识别客户](https://www.django-rest-framework.org/api-guide/throttling/#how-clients-are-identified)

的`X-Forwarded-For`HTTP报头和`REMOTE_ADDR`WSGI变量被用来唯一地标识为节流客户端的IP地址。如果存在`X-Forwarded-For`标头，则将使用它，否则`REMOTE_ADDR`将使用WSGI环境中的变量值。

如果需要严格标识唯一的客户端IP地址，则需要先通过设置`NUM_PROXIES`设置配置API落后的应用代理数量。此设置应为零或更大的整数。如果设置为非零，则`X-Forwarded-For`一旦首次排除任何应用程序代理IP地址，客户端IP将被标识为标头中的最后一个IP地址。如果设置为零，则该`REMOTE_ADDR`值将始终用作标识IP地址。

重要的是要了解，如果您配置此`NUM_PROXIES`设置，则唯一[经过NAT转换的](https://en.wikipedia.org/wiki/Network_address_translation)网关后面的所有客户端都将被视为单个客户端。

`X-Forwarded-For`您可以[在此处找到](http://oxpedia.org/wiki/index.php?title=AppSuite:Grizzly#Multiple_Proxies_in_front_of_the_cluster)有关标头如何工作以及标识远程客户端IP的更多上下文。

## [设置缓存](https://www.django-rest-framework.org/api-guide/throttling/#setting-up-the-cache)

REST框架提供的节流类使用Django的缓存后端。您应该确保已设置适当的[缓存设置](https://docs.djangoproject.com/en/stable/ref/settings/#caches)。`LocMemCache`对于简单的设置，后端的默认值应该可以。有关更多详细信息，请参见Django的[缓存文档](https://docs.djangoproject.com/en/stable/topics/cache/#setting-up-the-cache)。

如果您需要使用以外的其他缓存`'default'`，则可以通过创建自定义的油门类并设置`cache`属性来实现。例如：

```python
from django.core.cache import caches

class CustomAnonRateThrottle(AnonRateThrottle):
    cache = caches['alternate']
```

您需要记住还要在`'DEFAULT_THROTTLE_CLASSES'`设置键或使用`throttle_classes`view属性中设置自定义油门类。

------

# [API参考](https://www.django-rest-framework.org/api-guide/throttling/#api-reference)

## [AnonRateThrottle](https://www.django-rest-framework.org/api-guide/throttling/#anonratethrottle)

该`AnonRateThrottle`会永远只能扼杀未经授权的用户。传入请求的IP地址用于生成唯一的密钥以进行限制。

允许的请求速率由以下之一确定（按优先顺序）。

- 所述`rate`的类，其可以通过覆盖被提供的属性`AnonRateThrottle`和设置属性。
- 该`DEFAULT_THROTTLE_RATES['anon']`设置。

`AnonRateThrottle` 如果您想限制来自未知来源的请求速率，则适用。

## [UserRateThrottle](https://www.django-rest-framework.org/api-guide/throttling/#userratethrottle)

在`UserRateThrottle`将油门用户跨API请求给定的速度。用户ID用于生成唯一的密钥以进行限制。未经身份验证的请求将退回到使用传入请求的IP地址来生成唯一密钥以进行限制。

允许的请求速率由以下之一确定（按优先顺序）。

- 所述`rate`的类，其可以通过覆盖被提供的属性`UserRateThrottle`和设置属性。
- 该`DEFAULT_THROTTLE_RATES['user']`设置。

一个API可能同时具有多个`UserRateThrottles`位置。为此，请`UserRateThrottle`为每个类重写并设置一个唯一的“作用域”。

例如，可以使用以下类来实现多个用户节流率。

```python
class BurstRateThrottle(UserRateThrottle):
    scope = 'burst'

class SustainedRateThrottle(UserRateThrottle):
    scope = 'sustained'
```

...以及以下设置。

```python
REST_FRAMEWORK = {
    'DEFAULT_THROTTLE_CLASSES': [
        'example.throttles.BurstRateThrottle',
        'example.throttles.SustainedRateThrottle'
    ],
    'DEFAULT_THROTTLE_RATES': {
        'burst': '60/min',
        'sustained': '1000/day'
    }
}
```

`UserRateThrottle` 如果您希望对每个用户进行简单的全局速率限制，则适用。

## [ScopedRateThrottle](https://www.django-rest-framework.org/api-guide/throttling/#scopedratethrottle)

的`ScopedRateThrottle`类可用于限制访问API的特定部分。仅当所访问的视图包含`.throttle_scope`属性时，才会应用此限制。然后，通过将请求的“范围”与唯一的用户ID或IP地址串联起来，即可形成唯一的限制键。

允许的请求速率由`DEFAULT_THROTTLE_RATES`设置使用请求“范围”中的键确定。

例如，给定以下视图...

```python
class ContactListView(APIView):
    throttle_scope = 'contacts'
    ...

class ContactDetailView(APIView):
    throttle_scope = 'contacts'
    ...

class UploadView(APIView):
    throttle_scope = 'uploads'
    ...
```

...以及以下设置。

```python
REST_FRAMEWORK = {
    'DEFAULT_THROTTLE_CLASSES': [
        'rest_framework.throttling.ScopedRateThrottle',
    ],
    'DEFAULT_THROTTLE_RATES': {
        'contacts': '1000/day',
        'uploads': '20/day'
    }
}
```

用户每天对一个请求的请求`ContactListView`或`ContactDetailView`将被限制为总共1000个请求。用户对的请求`UploadView`将被限制为每天20个请求。

------

# [定制油门](https://www.django-rest-framework.org/api-guide/throttling/#custom-throttles)

要创建自定义节流阀，请覆盖`BaseThrottle`并实施`.allow_request(self, request, view)`。`True`如果应允许该请求，则该方法应返回，`False`否则返回。

（可选）您也可以覆盖该`.wait()`方法。如果已实施，`.wait()`则应返回建议的秒数，以等待下一个请求，或者`None`。`.wait()`如果`.allow_request()`先前已返回，则将仅调用该方法`False`。

如果该`.wait()`方法已实现且请求已被限制，则`Retry-After`标头将包含在响应中。

## [例](https://www.django-rest-framework.org/api-guide/throttling/#example)

以下是速率调节的示例，它将在每10个请求中随机调节1个。

```python
import random

class RandomRateThrottle(throttling.BaseThrottle):
    def allow_request(self, request, view):
        return random.randint(1, 10) != 1
```