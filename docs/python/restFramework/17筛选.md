# [筛选](https://www.django-rest-framework.org/api-guide/filtering/#filtering)

> Manager提供的根QuerySet描述了数据库表中的所有对象。通常，尽管如此，您只需要选择完整对象集的一个子集。
>
> — [Django文档](https://docs.djangoproject.com/en/stable/topics/db/queries/#retrieving-specific-objects-with-filters)

REST框架的通用列表视图的默认行为是返回模型管理器的整个查询集。通常，您会希望您的API限制查询集返回的项目。

筛选子类的任何视图的查询集的最简单方法`GenericAPIView`是覆盖该`.get_queryset()`方法。

通过覆盖此方法，您可以通过多种不同方式自定义视图返回的查询集。

## [针对当前用户进行过滤](https://www.django-rest-framework.org/api-guide/filtering/#filtering-against-the-current-user)

您可能希望过滤查询集以确保仅返回与发出请求的当前经过身份验证的用户有关的结果。

您可以根据的值进行过滤`request.user`。

例如：

```python
from myapp.models import Purchase
from myapp.serializers import PurchaseSerializer
from rest_framework import generics

class PurchaseList(generics.ListAPIView):
    serializer_class = PurchaseSerializer

    def get_queryset(self):
        """
        This view should return a list of all the purchases
        for the currently authenticated user.
        """
        user = self.request.user
        return Purchase.objects.filter(purchaser=user)
```

## [根据网址过滤](https://www.django-rest-framework.org/api-guide/filtering/#filtering-against-the-url)

另一种过滤方式可能涉及基于URL的某些部分限制查询集。

例如，如果您的URL配置包含这样的条目：

```python
url('^purchases/(?P<username>.+)/$', PurchaseList.as_view()),
```

然后，您可以编写一个视图，该视图返回按URL的用户名部分过滤的购买查询集：

```python
class PurchaseList(generics.ListAPIView):
    serializer_class = PurchaseSerializer

    def get_queryset(self):
        """
        This view should return a list of all the purchases for
        the user as determined by the username portion of the URL.
        """
        username = self.kwargs['username']
        return Purchase.objects.filter(purchaser__username=username)
```

## [根据查询参数过滤](https://www.django-rest-framework.org/api-guide/filtering/#filtering-against-query-parameters)

过滤初始查询集的最后一个示例是根据url中的查询参数确定初始查询集。

我们可以重写`.get_queryset()`以处理诸如的URL `http://example.com/api/purchases?username=denvercoder9`，仅`username`在URL中包含参数时才过滤查询集：

```python
class PurchaseList(generics.ListAPIView):
    serializer_class = PurchaseSerializer

    def get_queryset(self):
        """
        Optionally restricts the returned purchases to a given user,
        by filtering against a `username` query parameter in the URL.
        """
        queryset = Purchase.objects.all()
        username = self.request.query_params.get('username', None)
        if username is not None:
            queryset = queryset.filter(purchaser__username=username)
        return queryset
```

------

# [通用过滤](https://www.django-rest-framework.org/api-guide/filtering/#generic-filtering)

REST框架不仅可以覆盖默认查询集，而且还支持通用过滤后端，使您可以轻松构建复杂的搜索和过滤器。

通用过滤器还可以将自己显示为可浏览API和admin API中的HTML控件。

![筛选范例](https://www.django-rest-framework.org/img/filter-controls.png)

## [设置过滤器后端](https://www.django-rest-framework.org/api-guide/filtering/#setting-filter-backends)

可以使用该`DEFAULT_FILTER_BACKENDS`设置全局设置默认过滤器后端。例如。

```python
REST_FRAMEWORK = {
    'DEFAULT_FILTER_BACKENDS': ['django_filters.rest_framework.DjangoFilterBackend']
}
```

您还可以使用`GenericAPIView`基于类的视图基于每个视图或每个视图集设置过滤器后端。

```python
import django_filters.rest_framework
from django.contrib.auth.models import User
from myapp.serializers import UserSerializer
from rest_framework import generics

class UserListView(generics.ListAPIView):
    queryset = User.objects.all()
    serializer_class = UserSerializer
    filter_backends = [django_filters.rest_framework.DjangoFilterBackend]
```

## [过滤和对象查找](https://www.django-rest-framework.org/api-guide/filtering/#filtering-and-object-lookups)

请注意，如果为视图配置了过滤器后端，则该过滤器后端不仅用于过滤列表视图，还将用于过滤用于返回单个对象的查询集。

例如，给定前面的示例以及id为的产品`4675`，以下URL将返回相应的对象或返回404响应，具体取决于给定产品实例是否满足过滤条件：

```python
http://example.com/api/products/4675/?category=clothing&max_price=10.00
```

## [覆盖初始查询集](https://www.django-rest-framework.org/api-guide/filtering/#overriding-the-initial-queryset)

请注意，您可以同时使用覆盖`.get_queryset()`过滤和通用过滤，一切都会按预期进行。例如，如果`Product`与`User`名为的多对多关系`purchase`，则可能需要编写如下视图：

```python
class PurchasedProductsList(generics.ListAPIView):
    """
    Return a list of all the products that the authenticated
    user has ever purchased, with optional filtering.
    """
    model = Product
    serializer_class = ProductSerializer
    filterset_class = ProductFilter

    def get_queryset(self):
        user = self.request.user
        return user.purchase_set.all()
```

------

# [API指南](https://www.django-rest-framework.org/api-guide/filtering/#api-guide)

## [DjangoFilterBackend](https://www.django-rest-framework.org/api-guide/filtering/#djangofilterbackend)

该[`django-filter`](https://django-filter.readthedocs.io/en/latest/index.html)库包含一个`DjangoFilterBackend`类，该类支持针对REST框架的高度可自定义的字段筛选。

要使用`DjangoFilterBackend`，请先安装`django-filter`。然后添加`django_filters`到Django的`INSTALLED_APPS`

```python
pip install django-filter
```

现在，您应该将过滤器后端添加到您的设置中：

```python
REST_FRAMEWORK = {
    'DEFAULT_FILTER_BACKENDS': ['django_filters.rest_framework.DjangoFilterBackend']
}
```

或将过滤器后端添加到单个View或ViewSet。

```python
from django_filters.rest_framework import DjangoFilterBackend

class UserListView(generics.ListAPIView):
    ...
    filter_backends = [DjangoFilterBackend]
```

如果只需要简单的基于等式的过滤，则可以`filterset_fields`在视图或视图集上设置一个属性，列出要过滤的字段集。

```python
class ProductList(generics.ListAPIView):
    queryset = Product.objects.all()
    serializer_class = ProductSerializer
    filter_backends = [DjangoFilterBackend]
    filterset_fields = ['category', 'in_stock']
```

这将自动`FilterSet`为给定的字段创建一个类，并允许您发出如下请求：

```python
http://example.com/api/products?category=clothing&in_stock=True
```

对于更高级的过滤要求，您可以指定`FilterSet`视图应使用的类。您可以`FilterSet`在[django-filter文档中](https://django-filter.readthedocs.io/en/latest/index.html)阅读有关的更多信息。还建议您阅读有关[DRF集成](https://django-filter.readthedocs.io/en/latest/guide/rest_framework.html)的部分。

## [SearchFilter](https://www.django-rest-framework.org/api-guide/filtering/#searchfilter)

该`SearchFilter`级支持简单单的查询参数基于搜索和基于该[admin界面的搜索功能](https://docs.djangoproject.com/en/stable/ref/contrib/admin/#django.contrib.admin.ModelAdmin.search_fields)。

使用时，可浏览的API将包含一个`SearchFilter`控件：

![搜索过滤器](https://www.django-rest-framework.org/img/search-filter.png)

所述`SearchFilter`如果视图有一类将只应用于`search_fields`属性集。该`search_fields`属性应该是模型上文本类型字段名称的列表，例如`CharField`或`TextField`。

```python
from rest_framework import filters

class UserListView(generics.ListAPIView):
    queryset = User.objects.all()
    serializer_class = UserSerializer
    filter_backends = [filters.SearchFilter]
    search_fields = ['username', 'email']
```

这将允许客户端通过执行以下查询来过滤列表中的项目：

```python
http://example.com/api/users?search=russell
```

您还可以使用查找API双下划线表示法在ForeignKey或ManyToManyField上执行相关查找：

```python
search_fields = ['username', 'email', 'profile__profession']
```

默认情况下，搜索将使用不区分大小写的部分匹配。搜索参数可以包含多个搜索词，应将其用空格和/或逗号分隔。如果使用多个搜索词，则仅当所有提供的词都匹配时，对象才会在列表中返回。

可以通过在前面加上各种字符来限制搜索行为`search_fields`。

- '^'开始搜索。
- '='完全匹配。
- '@'全文搜索。（当前仅支持Django的MySQL后端。）
- '$'正则表达式搜索。

例如：

```python
search_fields = ['=username', '=email']
```

默认情况下，搜索参数名为`'search'`，但是此参数可能会被`SEARCH_PARAM`设置覆盖。

要根据请求内容动态更改搜索字段，可以对进行子类化`SearchFilter`并覆盖该`get_search_fields()`函数。例如，以下子类仅`title`在查询参数`title_only`在请求中时才搜索：

```python
from rest_framework import filters

class CustomSearchFilter(filters.SearchFilter):
    def get_search_fields(self, view, request):
        if request.query_params.get('title_only'):
            return ['title']
        return super(CustomSearchFilter, self).get_search_fields(view, request)
```

有关更多详细信息，请参见[Django文档](https://docs.djangoproject.com/en/stable/ref/contrib/admin/#django.contrib.admin.ModelAdmin.search_fields)。

------

## [订购过滤器](https://www.django-rest-framework.org/api-guide/filtering/#orderingfilter)

本`OrderingFilter`类支持的结果简单的查询参数进行控制顺序。

![订购过滤器](https://www.django-rest-framework.org/img/ordering-filter.png)

默认情况下，查询参数名为`'ordering'`，但这可以被`ORDERING_PARAM`设置覆盖。

例如，按用户名订购用户：

```
http://example.com/api/users?ordering=username
```

客户端还可以通过在字段名称前添加“-”来指定相反的顺序，如下所示：

```
http://example.com/api/users?ordering=-username
```

也可以指定多个顺序：

```
http://example.com/api/users?ordering=account,username
```

### [指定可以针对哪些字段进行排序](https://www.django-rest-framework.org/api-guide/filtering/#specifying-which-fields-may-be-ordered-against)

建议您明确指定API应在排序过滤器中允许的字段。您可以通过`ordering_fields`在视图上设置属性来做到这一点，如下所示：

```python
class UserListView(generics.ListAPIView):
    queryset = User.objects.all()
    serializer_class = UserSerializer
    filter_backends = [filters.OrderingFilter]
    ordering_fields = ['username', 'email']
```

这有助于防止意外的数据泄漏，例如允许用户针对密码哈希字段或其他敏感数据进行排序。

如果*未*`ordering_fields`在视图上指定属性，则过滤器类将默认为允许用户对由`serializer_class`属性指定的序列化器上的任何可读字段进行过滤。

如果您确信该视图使用的查询集不包含任何敏感数据，则还可以通过使用special值明确指定一个视图应允许对*任何*模型字段或查询集集合进行排序`'__all__'`。

```python
class BookingsListView(generics.ListAPIView):
    queryset = Booking.objects.all()
    serializer_class = BookingSerializer
    filter_backends = [filters.OrderingFilter]
    ordering_fields = '__all__'
```

### [指定默认顺序](https://www.django-rest-framework.org/api-guide/filtering/#specifying-a-default-ordering)

如果`ordering`在视图上设置了属性，它将用作默认顺序。

通常，您可以通过`order_by`在初始查询集上进行设置来控制此操作，但是使用`ordering`视图上的参数可以指定顺序，然后将其作为上下文自动传递到呈现的模板。如果使用列标题对结果进行排序，则可以自动以不同的方式呈现列标题。

```python
class UserListView(generics.ListAPIView):
    queryset = User.objects.all()
    serializer_class = UserSerializer
    filter_backends = [filters.OrderingFilter]
    ordering_fields = ['username', 'email']
    ordering = ['username']
```

该`ordering`属性可以是字符串，也可以是字符串列表/元组。

------

# [自定义通用过滤](https://www.django-rest-framework.org/api-guide/filtering/#custom-generic-filtering)

您还可以提供自己的通用过滤后端，或编写供其他开发人员使用的可安装应用。

为此，请重写`BaseFilterBackend`，并重写`.filter_queryset(self, request, queryset, view)`方法。该方法应返回一个经过过滤的新查询集。

除了允许客户端执行搜索和过滤外，通用过滤器后端对于限制对任何给定请求或用户应可见的对象也很有用。

## [例](https://www.django-rest-framework.org/api-guide/filtering/#example)

例如，您可能需要限制用户只能看到他们创建的对象。

```python
class IsOwnerFilterBackend(filters.BaseFilterBackend):
    """
    Filter that only allows users to see their own objects.
    """
    def filter_queryset(self, request, queryset, view):
        return queryset.filter(owner=request.user)
```

我们可以通过覆盖`get_queryset()`视图来实现相同的行为，但是使用过滤器后端可以使您更轻松地将此限制添加到多个视图，或者将其应用于整个API。

## [定制界面](https://www.django-rest-framework.org/api-guide/filtering/#customizing-the-interface)

通用过滤器也可以在可浏览的API中提供接口。为此，您应该实现一个`to_html()`方法，该方法返回过滤器的呈现的HTML表示形式。此方法应具有以下签名：

```python
to_html(self, request, queryset, view)
```

该方法应返回呈现的HTML字符串。

## [分页和模式](https://www.django-rest-framework.org/api-guide/filtering/#pagination-schemas)

您还可以通过实现一种`get_schema_fields()`方法，使过滤器控件可用于REST框架提供的模式自动生成。此方法应具有以下签名：

```python
get_schema_fields(self, view)
```

该方法应返回`coreapi.Field`实例列表。

# [第三方套餐](https://www.django-rest-framework.org/api-guide/filtering/#third-party-packages)

以下第三方软件包提供了其他过滤器实现。

## [Django REST框架过滤器软件包](https://www.django-rest-framework.org/api-guide/filtering/#django-rest-framework-filters-package)

在[Django的休息框架过滤器封装](https://github.com/philipn/django-rest-framework-filters)与一起工作`DjangoFilterBackend`类，并允许您轻松地在关系创建过滤器，或在指定字段创建多个过滤器查找类型。

## [Django REST框架全字搜索过滤器](https://www.django-rest-framework.org/api-guide/filtering/#django-rest-framework-full-word-search-filter)

该[djangorestframework词过滤](https://github.com/trollknurr/django-rest-framework-word-search-filter)开发作为替代品`filters.SearchFilter`，这将搜索文本完整的单词，或精确匹配。

## [Django URL过滤器](https://www.django-rest-framework.org/api-guide/filtering/#django-url-filter)

[django-url-filter](https://github.com/miki725/django-url-filter)提供了一种通过人类友好的URL过滤数据的安全方法。从某种意义上说，它可以嵌套，除了它们称为过滤器集和过滤器外，它的工作方式与DRF序列化器和字段非常相似。这提供了过滤相关数据的简便方法。该库也是通用的，因此可以用来过滤其他数据源，而不仅仅是Django `QuerySet`。

## [drf-url-filters](https://www.django-rest-framework.org/api-guide/filtering/#drf-url-filters)

[DRF-URL过滤](https://github.com/manjitkumar/drf-url-filters)是一个简单的Django应用程序对DRF应用滤镜`ModelViewSet`的`Queryset`一个清洁，简单和可配置的方式。它还支持对传入查询参数及其值的验证。一个漂亮的python包`Voluptuous`用于对传入的查询参数进行验证。关于性感的最好的部分是您可以根据查询参数要求定义自己的验证。