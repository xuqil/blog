# [分页](https://www.django-rest-framework.org/api-guide/pagination/#pagination)

> Django提供了一些类来帮助您管理分页数据，即通过“上一页/下一页”链接拆分到多个页面的数据。
>
> — [Django文档](https://docs.djangoproject.com/en/stable/topics/pagination/)

REST框架包括对可定制的分页样式的支持。这使您可以修改将多大结果集拆分为单个数据页。

分页API可以支持以下任一功能：

- 作为响应内容一部分提供的分页链接。
- 响应标头中包含的分页链接，例如`Content-Range`或`Link`。

当前，内置样式均使用作为响应内容一部分包含的链接。使用可浏览的API时，此样式更易于访问。

仅在使用通用视图或视图集时才自动执行分页。如果您使用的是常规`APIView`，则需要自己调用分页API，以确保您返回分页响应。有关示例，请参见`mixins.ListModelMixin`和`generics.GenericAPIView`类的源代码。

可以通过将分页类别设置为来关闭分页`None`。

## [设置分页样式](https://www.django-rest-framework.org/api-guide/pagination/#setting-the-pagination-style)

分页样式可以使用`DEFAULT_PAGINATION_CLASS`和`PAGE_SIZE`设置键进行全局设置。例如，要使用内置的限制/偏移分页，您可以执行以下操作：

```python
REST_FRAMEWORK = {
    'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.LimitOffsetPagination',
    'PAGE_SIZE': 100
}
```

请注意，您需要同时设置分页类和应使用的页面大小。双方`DEFAULT_PAGINATION_CLASS`并`PAGE_SIZE`都`None`默认。

您也可以使用`pagination_class`属性在单个视图上设置分页类。通常，您可能希望在整个API中使用相同的分页样式，尽管您可能希望根据每个视图改变分页的各个方面，例如默认或最大页面大小。

## [修改分页样式](https://www.django-rest-framework.org/api-guide/pagination/#modifying-the-pagination-style)

如果要修改分页样式的特定方面，则需要覆盖其中一个分页类，并设置要更改的属性。

```python
class LargeResultsSetPagination(PageNumberPagination):
    page_size = 1000
    page_size_query_param = 'page_size'
    max_page_size = 10000

class StandardResultsSetPagination(PageNumberPagination):
    page_size = 100
    page_size_query_param = 'page_size'
    max_page_size = 1000
```

然后，您可以使用`pagination_class`属性将新样式应用于视图：

```python
class BillingRecordsView(generics.ListAPIView):
    queryset = Billing.objects.all()
    serializer_class = BillingRecordsSerializer
    pagination_class = LargeResultsSetPagination
```

或使用`DEFAULT_PAGINATION_CLASS`设置键全局应用样式。例如：

```python
REST_FRAMEWORK = {
    'DEFAULT_PAGINATION_CLASS': 'apps.core.pagination.StandardResultsSetPagination'
}
```

------

# [API参考](https://www.django-rest-framework.org/api-guide/pagination/#api-reference)

## [PageNumberPagination](https://www.django-rest-framework.org/api-guide/pagination/#pagenumberpagination)

此分页样式在请求查询参数中接受单个数字页码。

**要求**：

```
GET https://api.example.org/accounts/?page=4
```

**回应**：

```json
HTTP 200 OK
{
    "count": 1023
    "next": "https://api.example.org/accounts/?page=5",
    "previous": "https://api.example.org/accounts/?page=3",
    "results": [
       …
    ]
}
```

#### [设定](https://www.django-rest-framework.org/api-guide/pagination/#setup)

要`PageNumberPagination`全局启用样式，请使用以下配置，然后`PAGE_SIZE`根据需要进行设置：

```python
REST_FRAMEWORK = {
    'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.PageNumberPagination',
    'PAGE_SIZE': 100
}
```

在`GenericAPIView`子类上，您还可以设置`pagination_class`属性以`PageNumberPagination`基于每个视图进行选择。

#### [组态](https://www.django-rest-framework.org/api-guide/pagination/#configuration)

所述`PageNumberPagination`类包括多个可重写修改分页样式属性。

要设置这些属性，您应该覆盖`PageNumberPagination`该类，然后如上所述启用您的自定义分页类。

- `django_paginator_class`-要使用的Django Paginator类。默认值为`django.core.paginator.Paginator`，在大多数情况下都可以使用。
- `page_size`-指示页面大小的数值。如果设置，则此`PAGE_SIZE`设置将覆盖设置。默认值为与`PAGE_SIZE`设置键相同的值。
- `page_query_param` -一个字符串值，指示用于分页控件的查询参数的名称。
- `page_size_query_param`-如果设置，则这是一个字符串值，指示查询参数的名称，该参数允许客户端根据每个请求设置页面大小。默认为`None`，表示客户端可能无法控制请求的页面大小。
- `max_page_size`-如果设置，这是一个数字值，表示请求的最大允许页面大小。只有`page_size_query_param`同时设置了此属性，该属性才有效。
- `last_page_strings`-字符串值的列表或元组，指示可与一起使用`page_query_param`以请求集合中的最后一页的值。默认为`('last',)`
- `template`-在可浏览的API中呈现分页控件时要使用的模板的名称。可以重写以修改呈现样式，或设置为`None`完全禁用HTML分页控件。默认为`"rest_framework/pagination/numbers.html"`。

------

## [LimitOffsetPagination](https://www.django-rest-framework.org/api-guide/pagination/#limitoffsetpagination)

这种分页样式反映了查找多个数据库记录时使用的语法。客户端同时包括“限制”和“偏移”查询参数。该限制指示要返回的最大项目数，并且与`page_size`其他样式相同。偏移量表示查询相对于未分页项的完整集合的开始位置。

**要求**：

```
GET https://api.example.org/accounts/?limit=100&offset=400
```

**回应**：

```json
HTTP 200 OK
{
    "count": 1023
    "next": "https://api.example.org/accounts/?limit=100&offset=500",
    "previous": "https://api.example.org/accounts/?limit=100&offset=300",
    "results": [
       …
    ]
}
```

#### [设定](https://www.django-rest-framework.org/api-guide/pagination/#setup_1)

要`LimitOffsetPagination`全局启用样式，请使用以下配置：

```python
REST_FRAMEWORK = {
    'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.LimitOffsetPagination'
}
```

您也可以选择设置一个`PAGE_SIZE`密钥。如果`PAGE_SIZE`还使用了该参数，则`limit`查询参数将是可选的，并且客户端可以将其省略。

在`GenericAPIView`子类上，您还可以设置`pagination_class`属性以`LimitOffsetPagination`基于每个视图进行选择。

#### [组态](https://www.django-rest-framework.org/api-guide/pagination/#configuration_1)

所述`LimitOffsetPagination`类包括多个可重写修改分页样式属性。

要设置这些属性，您应该覆盖`LimitOffsetPagination`该类，然后如上所述启用您的自定义分页类。

- `default_limit`-一个数值，指示客户端未在查询参数中提供限制时使用的限制。默认值为与`PAGE_SIZE`设置键相同的值。
- `limit_query_param`-指示“ limit”查询参数名称的字符串值。默认为`'limit'`。
- `offset_query_param`-一个字符串值，指示“偏移”查询参数的名称。默认为`'offset'`。
- `max_limit`-如果设置了此值，则该值表示客户端可能请求的最大允许限制。默认为`None`。
- `template`-在可浏览的API中呈现分页控件时要使用的模板的名称。可以重写以修改呈现样式，或设置为`None`完全禁用HTML分页控件。默认为`"rest_framework/pagination/numbers.html"`。

------

## [光标分页](https://www.django-rest-framework.org/api-guide/pagination/#cursorpagination)

基于光标的分页显示不透明的“光标”指示符，客户端可以使用该指示符来翻阅结果集。此分页样式仅显示前进和后退控件，并且不允许客户端导航到任意位置。

基于游标的分页要求结果集中的项目顺序唯一，不变。该排序通常可能是记录上的创建时间戳，因为这表示要进行分页的一致顺序。

基于游标的分页比其他方案更为复杂。它还要求结果集呈现固定的顺序，并且不允许客户端任意索引到结果集中。但是，它确实具有以下好处：

- 提供一致的分页视图。如果使用得当，`CursorPagination`可以确保客户端在翻阅记录时永远不会看到相同的项目两次，即使在分页过程中其他客户端插入了新项目时也是如此。
- 支持使用非常大的数据集。对于非常大的数据集，使用基于偏移的分页样式的分页可能会变得效率低下或无法使用。相反，基于游标的分页方案具有固定时间属性，并且不会随着数据集大小的增加而变慢。

#### [细节和限制](https://www.django-rest-framework.org/api-guide/pagination/#details-and-limitations)

正确使用基于光标的分页需要稍微注意细节。您需要考虑要对方案应用哪种排序。默认设置为排序`"-created"`。假设在模型实例上**必须有一个“创建的”时间戳字段**，并且将显示“时间轴”样式的分页视图，其中最近添加的项优先。

您可以通过覆盖`'ordering'`分页类上的属性或将`OrderingFilter`过滤器类与一起使用来修改顺序`CursorPagination`。与之一起使用时，`OrderingFilter`应强烈考虑限制用户订购的字段。

正确使用游标分页应具有满足以下条件的排序字段：

- 创建时应为不变的值，例如时间戳记，段标或仅设置一次的其他字段。
- 应该是唯一的，或者几乎是唯一的。毫秒精度时间戳就是一个很好的例子。游标分页的此实现使用智能的“位置加偏移”样式，该样式允许它正确地支持非严格唯一的值作为顺序。
- 应该是可以强制转换为字符串的非空值。
- 不应该是浮点数。精度错误很容易导致错误的结果。提示：请改用小数。（如果您已经有一个float字段，并且必须对此进行分页，[则此处提供了](https://gist.github.com/keturn/8bc88525a183fd41c73ffb729b8865be#file-fpcursorpagination-py)一个[使用小数来限制精度](https://gist.github.com/keturn/8bc88525a183fd41c73ffb729b8865be#file-fpcursorpagination-py)的 [示例`CursorPagination`子类](https://gist.github.com/keturn/8bc88525a183fd41c73ffb729b8865be#file-fpcursorpagination-py)。）
- 该字段应具有数据库索引。

使用不满足这些约束的排序字段通常仍然可以使用，但是您将失去光标分页的某些好处。

有关我们用于游标分页的实现的更多技术细节，博客文章[“为Disqus API构建游标”](https://cra.mr/2011/03/08/building-cursors-for-the-disqus-api)很好地概述了基本方法。

#### [设定](https://www.django-rest-framework.org/api-guide/pagination/#setup_2)

要`CursorPagination`全局启用样式，请使用以下配置，并`PAGE_SIZE`根据需要进行修改：

```python
REST_FRAMEWORK = {
    'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.CursorPagination',
    'PAGE_SIZE': 100
}
```

在`GenericAPIView`子类上，您还可以设置`pagination_class`属性以`CursorPagination`基于每个视图进行选择。

#### [组态](https://www.django-rest-framework.org/api-guide/pagination/#configuration_2)

所述`CursorPagination`类包括多个可重写修改分页样式属性。

要设置这些属性，您应该覆盖`CursorPagination`该类，然后如上所述启用您的自定义分页类。

- `page_size`=指示页面大小的数值。如果设置，则此`PAGE_SIZE`设置将覆盖设置。默认值为与`PAGE_SIZE`设置键相同的值。
- `cursor_query_param`=一个字符串值，指示“ cursor”查询参数的名称。默认为`'cursor'`。
- `ordering`=这应该是一个字符串或字符串列表，指示将基于光标的分页应用于的字段。例如：`ordering = 'slug'`。默认为`-created`。通过`OrderingFilter`在视图上使用，也可以覆盖此值。
- `template`=在可浏览的API中呈现分页控件时要使用的模板的名称。可以重写以修改呈现样式，或设置为`None`完全禁用HTML分页控件。默认为`"rest_framework/pagination/previous_and_next.html"`。

------

# [自定义分页样式](https://www.django-rest-framework.org/api-guide/pagination/#custom-pagination-styles)

要创建自定义的分页序列化程序类，您应该继承`pagination.BasePagination`并覆盖`paginate_queryset(self, queryset, request, view=None)`and `get_paginated_response(self, data)`方法：

- 该`paginate_queryset`方法将传递给初始查询集，并且应返回仅包含所请求页面中数据的可迭代对象。
- 该`get_paginated_response`方法将传递序列化的页面数据，并且应返回一个`Response`实例。

注意，该`paginate_queryset`方法可以在分页实例上设置状态，以后可以由该`get_paginated_response`方法使用。

## [例](https://www.django-rest-framework.org/api-guide/pagination/#example)

假设我们想用修改后的格式替换默认的分页输出样式，该格式在嵌套的“链接”键中包含下一个和上一个链接。我们可以这样指定一个自定义分页类：

```python
class CustomPagination(pagination.PageNumberPagination):
    def get_paginated_response(self, data):
        return Response({
            'links': {
                'next': self.get_next_link(),
                'previous': self.get_previous_link()
            },
            'count': self.page.paginator.count,
            'results': data
        })
```

然后，我们需要在配置中设置自定义类：

```python
REST_FRAMEWORK = {
    'DEFAULT_PAGINATION_CLASS': 'my_project.apps.core.pagination.CustomPagination',
    'PAGE_SIZE': 100
}
```

请注意，如果您关心按键的顺序在可浏览API中如何显示在响应中，则`OrderedDict`在构造分页响应正文时，您可能会选择使用，但这是可选的。

## [使用自定义分页类](https://www.django-rest-framework.org/api-guide/pagination/#using-your-custom-pagination-class)

要在默认情况下使用自定义分页类，请使用以下`DEFAULT_PAGINATION_CLASS`设置：

```python
REST_FRAMEWORK = {
    'DEFAULT_PAGINATION_CLASS': 'my_project.apps.core.pagination.LinkHeaderPagination',
    'PAGE_SIZE': 100
}
```

列表端点的API响应现在将包含`Link`标头，而不是将分页链接作为响应主体的一部分，例如：

![链接标题](https://www.django-rest-framework.org/img/link-header-pagination.png)

*使用“链接”标题的自定义分页样式*

## [分页和模式](https://www.django-rest-framework.org/api-guide/pagination/#pagination-schemas)

您还可以通过实现一种`get_schema_fields()`方法，使分页控件可用于REST框架提供的模式自动生成。此方法应具有以下签名：

```
get_schema_fields(self, view)
```

该方法应返回`coreapi.Field`实例列表。

------

# [HTML分页控件](https://www.django-rest-framework.org/api-guide/pagination/#html-pagination-controls)

默认情况下，使用分页类将导致HTML分页控件显示在可浏览的API中。有两种内置的显示样式。在`PageNumberPagination`与`LimitOffsetPagination`类显示页码与前一个和下一个列表控件。该`CursorPagination`级显示一个简单的风格，只显示前面和后面的控制。

## [自定义控件](https://www.django-rest-framework.org/api-guide/pagination/#customizing-the-controls)

您可以覆盖呈现HTML分页控件的模板。两种内置样式是：

- `rest_framework/pagination/numbers.html`
- `rest_framework/pagination/previous_and_next.html`

在全局模板目录中提供具有这些路径之一的模板将覆盖相关分页类的默认呈现。

另外，您可以通过对现有类进行子类化（在类上设置`template = None`为属性）来完全禁用HTML分页控件。然后，您需要配置`DEFAULT_PAGINATION_CLASS`设置键，以将自定义类用作默认的分页样式。

#### [低级API](https://www.django-rest-framework.org/api-guide/pagination/#low-level-api)

用于确定分页类是否应显示控件的低级API作为`display_page_controls`属性显示在分页实例上。如果自定义分页类要求显示HTML分页控件，则应`True`在`paginate_queryset`方法中将其设置为。

该`.to_html()`和`.get_html_context()`方法也可以被覆盖在自定义分页类，以进一步定制控件的呈现方式。

------

# [第三方套餐](https://www.django-rest-framework.org/api-guide/pagination/#third-party-packages)

以下第三方软件包也可用。

## [DRF扩展](https://www.django-rest-framework.org/api-guide/pagination/#drf-extensions)

该[`DRF-extensions`软件包](https://chibisov.github.io/drf-extensions/docs/)包括一个[`PaginateByMaxMixin`mixin类](https://chibisov.github.io/drf-extensions/docs/#paginatebymaxmixin)，[该类](https://chibisov.github.io/drf-extensions/docs/#paginatebymaxmixin)允许您的API客户端指定`?page_size=max`以获得最大允许页面大小。

## [drf-proxy分页](https://www.django-rest-framework.org/api-guide/pagination/#drf-proxy-pagination)

该[`drf-proxy-pagination`软件包](https://github.com/tuffnatty/drf-proxy-pagination)包括一个`ProxyPagination`类，该类允许选择带有查询参数的分页类。

## [链接头分页](https://www.django-rest-framework.org/api-guide/pagination/#link-header-pagination)

该[`django-rest-framework-link-header-pagination`软件包](https://github.com/tbeadle/django-rest-framework-link-header-pagination)包括一个`LinkHeaderPagination`类，该类通过[Github开发人员文档中](https://www.django-rest-framework.org/api-guide/pagination/github-link-pagination)`Link`描述的HTTP 标头提供分页。

