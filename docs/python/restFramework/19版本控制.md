# [版本控制](https://www.django-rest-framework.org/api-guide/versioning/#versioning)

> 对接口进行版本控制只是杀死已部署客户端的“礼貌”方式。
>
> — [罗伊·菲尔丁](https://www.slideshare.net/evolve_conference/201308-fielding-evolve/31)（[Roy Fielding）](https://www.slideshare.net/evolve_conference/201308-fielding-evolve/31)。

API版本控制使您可以更改不同客户端之间的行为。REST框架提供了许多不同的版本控制方案。

版本控制由传入的客户端请求确定，并且可以基于请求URL或基于请求标头。

存在许多有效的版本控制方法。[非版本化的系统也可能适用](https://www.infoq.com/articles/roy-fielding-on-versioning)，特别是如果您要为非常长期的系统进行工程设计时，有多个客户端不在您的控制范围内。

## [REST框架的版本控制](https://www.django-rest-framework.org/api-guide/versioning/#versioning-with-rest-framework)

启用API版本控制后，该`request.version`属性将包含一个字符串，该字符串与传入客户端请求中请求的版本相对应。

默认情况下，版本控制未启用，并且`request.version`将始终返回`None`。

#### [根据版本的不同行为](https://www.django-rest-framework.org/api-guide/versioning/#varying-behavior-based-on-the-version)

如何改变API的行为由您决定，但是您通常希望的一个示例是在较新的版本中切换到另一种序列化样式。例如：

```
def get_serializer_class(self):
    if self.request.version == 'v1':
        return AccountSerializerVersion1
    return AccountSerializer
```

#### [反转版本API的URL](https://www.django-rest-framework.org/api-guide/versioning/#reversing-urls-for-versioned-apis)

`reverse`REST框架包含的功能与版本控制方案相关联。您需要确保将current `request`作为关键字参数包含进来，就像这样。

```
from rest_framework.reverse import reverse

reverse('bookings-list', request=request)
```

上面的函数将适用于请求版本的所有URL转换。例如：

- 如果`NamespaceVersioning`正在使用，并且API版本为“ v1”，则使用的URL查找将为`'v1:bookings-list'`，它可能会解析为`http://example.org/v1/bookings/`。
- 如果`QueryParameterVersioning`正在使用，并且API版本为`1.0`，则返回的URL可能类似于`http://example.org/bookings/?version=1.0`

#### [版本化的API和超链接的序列化器](https://www.django-rest-framework.org/api-guide/versioning/#versioned-apis-and-hyperlinked-serializers)

当使用超链接的序列化样式以及基于URL的版本控制方案时，请确保将请求作为上下文包含到序列化器中。

```
def get(self, request):
    queryset = Booking.objects.all()
    serializer = BookingsSerializer(queryset, many=True, context={'request': request})
    return Response({'all_bookings': serializer.data})
```

这样做将允许所有返回的URL包含适当的版本控制。

## [配置版本控制方案](https://www.django-rest-framework.org/api-guide/versioning/#configuring-the-versioning-scheme)

版本`DEFAULT_VERSIONING_CLASS`设置方案由设置键定义。

```
REST_FRAMEWORK = {
    'DEFAULT_VERSIONING_CLASS': 'rest_framework.versioning.NamespaceVersioning'
}
```

除非明确设置，该值`DEFAULT_VERSIONING_CLASS`将是`None`。在这种情况下，`request.version`属性将始终返回`None`。

您还可以在单个视图上设置版本控制方案。通常，您不需要这样做，因为在全局范围内使用单个版本控制方案会更有意义。如果确实需要这样做，请使用该`versioning_class`属性。

```
class ProfileList(APIView):
    versioning_class = versioning.QueryParameterVersioning
```

#### [其他版本控制设置](https://www.django-rest-framework.org/api-guide/versioning/#other-versioning-settings)

以下设置键还用于控制版本控制：

- `DEFAULT_VERSION`。`request.version`不存在版本信息时应使用的值。默认为`None`。
- `ALLOWED_VERSIONS`。如果设置，则此值将限制版本控制方案可能返回的版本集，并且如果提供的版本不在此版本集中，则会引发错误。请注意，用于`DEFAULT_VERSION`设置的值始终被认为是`ALLOWED_VERSIONS`集合的一部分（除非它是`None`）。默认为`None`。
- `VERSION_PARAM`。任何版本控制参数都应使用的字符串，例如媒体类型或URL查询参数。默认为`'version'`。

您还可以设置你的版本类加上这三个值在每个视图或每个视图集基础上定义自己的版本控制方案和使用`default_version`，`allowed_versions`以及`version_param`类变量。例如，如果要使用`URLPathVersioning`：

```
from rest_framework.versioning import URLPathVersioning
from rest_framework.views import APIView

class ExampleVersioning(URLPathVersioning):
    default_version = ...
    allowed_versions = ...
    version_param = ...

class ExampleView(APIVIew):
    versioning_class = ExampleVersioning
```

------

# [API参考](https://www.django-rest-framework.org/api-guide/versioning/#api-reference)

## [AcceptHeaderVersioning](https://www.django-rest-framework.org/api-guide/versioning/#acceptheaderversioning)

此方案要求客户端在`Accept`标头中指定版本作为媒体类型的一部分。该版本作为媒体类型参数包括在内，它是对主要媒体类型的补充。

这是一个使用accept标头版本控制样式的HTTP请求示例。

```
GET /bookings/ HTTP/1.1
Host: example.com
Accept: application/json; version=1.0
```

在示例中，上面的request `request.version`属性将返回字符串`'1.0'`。

版本基础上接受头部被[普遍认为](http://blog.steveklabnik.com/posts/2011-07-03-nobody-understands-rest-or-http#i_want_my_api_to_be_versioned)是[最好的做法](https://github.com/interagent/http-api-design/blob/master/en/foundations/require-versioning-in-the-accepts-header.md)，但其他样式可能会根据您的客户的需求是合适的。

#### [对供应商媒体类型使用接受标头](https://www.django-rest-framework.org/api-guide/versioning/#using-accept-headers-with-vendor-media-types)

严格来说，`json`没有将媒体类型指定为[包含其他参数](https://tools.ietf.org/html/rfc4627#section-6)。如果您要构建指定明确的公共API，则可以考虑使用[供应商媒体类型](https://en.wikipedia.org/wiki/Internet_media_type#Vendor_tree)。为此，将渲染器配置为使用具有自定义媒体类型的基于JSON的渲染器：

```
class BookingsAPIRenderer(JSONRenderer):
    media_type = 'application/vnd.megacorp.bookings+json'
```

您的客户请求现在看起来像这样：

```
GET /bookings/ HTTP/1.1
Host: example.com
Accept: application/vnd.megacorp.bookings+json; version=1.0
```

## [URLPathVersioning](https://www.django-rest-framework.org/api-guide/versioning/#urlpathversioning)

此方案要求客户端将版本指定为URL路径的一部分。

```
GET /v1/bookings/ HTTP/1.1
Host: example.com
Accept: application/json
```

您的URL conf必须包含一个与版本和`'version'`关键字参数匹配的模式，以便此信息可用于版本控制方案。

```
urlpatterns = [
    re_path(
        r'^(?P<version>(v1|v2))/bookings/$',
        bookings_list,
        name='bookings-list'
    ),
    re_path(
        r'^(?P<version>(v1|v2))/bookings/(?P<pk>[0-9]+)/$',
        bookings_detail,
        name='bookings-detail'
    )
]
```

## [命名空间版本](https://www.django-rest-framework.org/api-guide/versioning/#namespaceversioning)

对于客户而言，此方案与相同`URLPathVersioning`。唯一的区别是它在Django应用程序中的配置方式，因为它使用URL名称间隔而不是URL关键字参数。

```
GET /v1/something/ HTTP/1.1
Host: example.com
Accept: application/json
```

使用此方案，`request.version`将根据`namespace`与传入请求路径匹配的属性来确定属性。

在以下示例中，我们为一组视图提供了两个不同的可能的URL前缀，每个前缀都在不同的命名空间下：

```
# bookings/urls.py
urlpatterns = [
    re_path(r'^$', bookings_list, name='bookings-list'),
    re_path(r'^(?P<pk>[0-9]+)/$', bookings_detail, name='bookings-detail')
]

# urls.py
urlpatterns = [
    re_path(r'^v1/bookings/', include('bookings.urls', namespace='v1')),
    re_path(r'^v2/bookings/', include('bookings.urls', namespace='v2'))
]
```

如果只需要简单的版本控制方案`URLPathVersioning`，`NamespaceVersioning`则两者和都是合理的。该`URLPathVersioning`方法可能更适合于小型临时项目，`NamespaceVersioning`对于大型项目可能更易于管理。

## [主机名版本](https://www.django-rest-framework.org/api-guide/versioning/#hostnameversioning)

主机名版本控制方案要求客户端在URL中指定请求的版本作为主机名的一部分。

例如，以下是对`http://v1.example.com/bookings/`URL 的HTTP请求：

```
GET /bookings/ HTTP/1.1
Host: v1.example.com
Accept: application/json
```

默认情况下，此实现期望主机名与以下简单正则表达式匹配：

```
^([a-zA-Z0-9]+)\.[a-zA-Z0-9]+\.[a-zA-Z0-9]+$
```

请注意，第一组括在方括号中，表明这是主机名的匹配部分。

`HostNameVersioning`在调试模式下使用该方案可能会很麻烦，因为您通常会访问原始IP地址，例如`127.0.0.1`。关于如何[使用自定义子域访问本地主机的](https://reinteractive.net/posts/199-developing-and-testing-rails-applications-with-subdomains)在线教程有很多，在这种情况下，您可能会有所帮助。

如果您有要求根据版本将传入的请求路由到其他服务器，则基于主机名的版本控制特别有用，因为您可以为不同的API版本配置不同的DNS记录。

## [QueryParameterVersioning](https://www.django-rest-framework.org/api-guide/versioning/#queryparameterversioning)

此方案是一种简单的样式，其中包括版本作为URL中的查询参数。例如：

```
GET /something/?version=0.1 HTTP/1.1
Host: example.com
Accept: application/json
```

------

# [自定义版本控制方案](https://www.django-rest-framework.org/api-guide/versioning/#custom-versioning-schemes)

要实现自定义版本控制方案，请子类化`BaseVersioning`并重写该`.determine_version`方法。

## [例](https://www.django-rest-framework.org/api-guide/versioning/#example)

以下示例使用自定义`X-API-Version`标头来确定请求的版本。

```
class XAPIVersionScheme(versioning.BaseVersioning):
    def determine_version(self, request, *args, **kwargs):
        return request.META.get('HTTP_X_API_VERSION', None)
```

如果您的版本控制方案基于请求URL，则您还需要更改确定版本URL的方式。为此，您应该覆盖`.reverse()`该类上的方法。有关示例，请参见源代码。