# [测试中](https://www.django-rest-framework.org/api-guide/testing/#testing)

> 没有测试的代码按设计被破坏。
>
> — [雅各布·卡普兰·莫斯](https://jacobian.org/writing/django-apps-with-buildout/#s-create-a-test-wrapper)

REST框架包括一些帮助程序类，这些类扩展了Django现有的测试框架，并改善了对发出API请求的支持。

# [APIRequestFactory](https://www.django-rest-framework.org/api-guide/testing/#apirequestfactory)

扩展[Django的现有`RequestFactory`类](https://docs.djangoproject.com/en/stable/topics/testing/advanced/#django.test.client.RequestFactory)。

## [创建测试请求](https://www.django-rest-framework.org/api-guide/testing/#creating-test-requests)

本`APIRequestFactory`类支持几乎相同的API来Django的标准`RequestFactory`类。这意味着，标准`.get()`，`.post()`，`.put()`，`.patch()`，`.delete()`，`.head()`和`.options()`方法都是可用的。

```
from rest_framework.test import APIRequestFactory

# Using the standard RequestFactory API to create a form POST request
factory = APIRequestFactory()
request = factory.post('/notes/', {'title': 'new idea'})
```

#### [使用`format`参数](https://www.django-rest-framework.org/api-guide/testing/#using-the-format-argument)

它创建一个请求体的方法，例如`post`，`put`和`patch`，包括`format`参数，该参数可以很容易地生成使用除多部分形式的数据以外的内容类型的请求。例如：

```
# Create a JSON POST request
factory = APIRequestFactory()
request = factory.post('/notes/', {'title': 'new idea'}, format='json')
```

默认情况下，可用格式为`'multipart'`和`'json'`。为了与Django现有兼容，`RequestFactory`默认格式为`'multipart'`。

要支持更多的请求格式集或更改默认格式，[请参阅“配置”部分](https://www.django-rest-framework.org/api-guide/testing/#configuration)。

#### [明确编码请求主体](https://www.django-rest-framework.org/api-guide/testing/#explicitly-encoding-the-request-body)

如果需要显式编码请求正文，可以通过设置`content_type`标志来进行编码。例如：

```
request = factory.post('/notes/', json.dumps({'title': 'new idea'}), content_type='application/json')
```

#### [使用表格数据进行PUT和PATCH](https://www.django-rest-framework.org/api-guide/testing/#put-and-patch-with-form-data)

值得注意的是Django `RequestFactory`和REST框架之间的区别`APIRequestFactory`是，多部分表单数据将被编码为just以外的方法`.post()`。

例如，使用`APIRequestFactory`，您可以发出表单PUT请求，如下所示：

```
factory = APIRequestFactory()
request = factory.put('/notes/547/', {'title': 'remember to email dave'})
```

使用Django的`RequestFactory`，您需要自己对数据进行显式编码：

```
from django.test.client import encode_multipart, RequestFactory

factory = RequestFactory()
data = {'title': 'remember to email dave'}
content = encode_multipart('BoUnDaRyStRiNg', data)
content_type = 'multipart/form-data; boundary=BoUnDaRyStRiNg'
request = factory.put('/notes/547/', content, content_type=content_type)
```

## [强制认证](https://www.django-rest-framework.org/api-guide/testing/#forcing-authentication)

使用请求工厂直接测试视图时，通常能够直接对请求进行身份验证，而不必构造正确的身份验证凭据，这通常很方便。

要强制验证请求，请使用`force_authenticate()`方法。

```
from rest_framework.test import force_authenticate

factory = APIRequestFactory()
user = User.objects.get(username='olivia')
view = AccountDetail.as_view()

# Make an authenticated request to the view...
request = factory.get('/accounts/django-superstars/')
force_authenticate(request, user=user)
response = view(request)
```

该方法的签名为`force_authenticate(request, user=None, token=None)`。进行呼叫时，可以设置用户和令牌中的一个或两个。

例如，当使用令牌强制进行身份验证时，您可能会执行以下操作：

```
user = User.objects.get(username='olivia')
request = factory.get('/accounts/django-superstars/')
force_authenticate(request, user=user, token=user.auth_token)
```

------

**注意**：`force_authenticate`直接设置`request.user`为内存中的`user`实例。如果要在`user`更新保存`user`状态的多个测试中重复使用同一实例，则可能需要[`refresh_from_db()`](https://docs.djangoproject.com/en/1.11/ref/models/instances/#django.db.models.Model.refresh_from_db)在测试之间调用。

------

**注意**：使用时`APIRequestFactory`，返回的对象是Django的standard `HttpRequest`，而不是REST框架的`Request`对象，该对象仅在调用视图后才生成。

这意味着直接在请求对象上设置属性可能并不总是具有预期的效果。例如，`.token`直接设置将无效，而`.user`直接设置仅在使用会话身份验证时才有效。

```
# Request will only authenticate if `SessionAuthentication` is in use.
request = factory.get('/accounts/django-superstars/')
request.user = user
response = view(request)
```

------

## [强制CSRF验证](https://www.django-rest-framework.org/api-guide/testing/#forcing-csrf-validation)

默认情况下，使用创建的请求`APIRequestFactory`在传递到REST框架视图时将不应用CSRF验证。如果需要显式打开CSRF验证，则可以通过`enforce_csrf_checks`在实例化工厂时设置标志来进行。

```
factory = APIRequestFactory(enforce_csrf_checks=True)
```

------

**注意**：值得注意的是，Django的标准`RequestFactory`不需要包含此选项，因为使用常规Django时，CSRF验证在中间件中进行，而中间件在直接测试视图时不会运行。使用REST框架时，CSRF验证在视图内部进行，因此请求工厂需要禁用视图级CSRF检查。

------

# [API客户端](https://www.django-rest-framework.org/api-guide/testing/#apiclient)

扩展[Django的现有`Client`类](https://docs.djangoproject.com/en/stable/topics/testing/tools/#the-test-client)。

## [发出请求](https://www.django-rest-framework.org/api-guide/testing/#making-requests)

本`APIClient`类支持相同的请求接口Django的标准`Client`类。这意味着，标准`.get()`，`.post()`，`.put()`，`.patch()`，`.delete()`，`.head()`和`.options()`方法都是可用的。例如：

```
from rest_framework.test import APIClient

client = APIClient()
client.post('/notes/', {'title': 'new idea'}, format='json')
```

要支持更多的请求格式集或更改默认格式，[请参阅“配置”部分](https://www.django-rest-framework.org/api-guide/testing/#configuration)。

## [验证中](https://www.django-rest-framework.org/api-guide/testing/#authenticating)

#### [.login（** kwargs）](https://www.django-rest-framework.org/api-guide/testing/#loginkwargs)

该`login`方法的功能与Django的常规`Client`类完全相同。这样，您就可以针对包含的任何视图对请求进行身份验证`SessionAuthentication`。

```
# Make all requests in the context of a logged in session.
client = APIClient()
client.login(username='lauren', password='secret')
```

要注销，请`logout`照常调用该方法。

```
# Log out
client.logout()
```

该`login`方法适用于测试使用会话身份验证的API，例如包含与API进行AJAX交互的网站。

#### [.credentials（** kwargs）](https://www.django-rest-framework.org/api-guide/testing/#credentialskwargs)

该`credentials`方法可用于设置标头，然后测试客户端会将其包含在所有后续请求中。

```
from rest_framework.authtoken.models import Token
from rest_framework.test import APIClient

# Include an appropriate `Authorization:` header on all requests.
token = Token.objects.get(user__username='lauren')
client = APIClient()
client.credentials(HTTP_AUTHORIZATION='Token ' + token.key)
```

请注意，`credentials`第二次调用将覆盖所有现有凭据。您可以通过不带任何参数的方法来取消设置任何现有的凭据。

```
# Stop including any credentials
client.credentials()
```

该`credentials`方法适用于测试需要身份验证标头的API，例如基本身份验证，OAuth1a和OAuth2身份验证以及简单令牌身份验证方案。

#### [.force_authenticate（用户=无，令牌=无）](https://www.django-rest-framework.org/api-guide/testing/#force_authenticateusernone-tokennone)

有时，您可能希望完全绕过身份验证，并强制将测试客户端的所有请求自动视为已身份验证。

如果您正在测试API但又不想构造有效的身份验证凭据来发出测试请求，则这可能是一个有用的快捷方式。

```
user = User.objects.get(username='lauren')
client = APIClient()
client.force_authenticate(user=user)
```

要取消对后续请求的`force_authenticate`身份验证，请调用将用户和/或令牌设置为`None`。

```
client.force_authenticate(user=None)
```

## [CSRF验证](https://www.django-rest-framework.org/api-guide/testing/#csrf-validation)

默认情况下，使用时不应用CSRF验证`APIClient`。如果需要显式启用CSRF验证，则可以通过`enforce_csrf_checks`在实例化客户端时设置标志来实现。

```
client = APIClient(enforce_csrf_checks=True)
```

与往常一样，CSRF验证仅适用于任何经过会话身份验证的视图。这意味着CSRF验证仅在通过调用登录了客户端后才会发生`login()`。

------

# [RequestsClient](https://www.django-rest-framework.org/api-guide/testing/#requestsclient)

REST框架还包括一个客户端，用于使用流行的Python库与您的应用程序进行交互`requests`。这在以下情况下可能有用：

- 您期望主要通过另一个Python服务与API进行接口，并希望在与客户端将看到的相同级别上测试服务。
- 您希望以这样的方式编写测试，使其也可以在暂存或实时环境中运行。（请参见下面的“实时测试”。）

这将显示与您直接使用请求会话完全相同的界面。

```
from rest_framework.test import RequestsClient

client = RequestsClient()
response = client.get('http://testserver/users/')
assert response.status_code == 200
```

请注意，请求客户端要求您传递完全限定的URL。

## [RequestsClient并使用数据库](https://www.django-rest-framework.org/api-guide/testing/#requestsclient-and-working-with-the-database)

的`RequestsClient`，如果你想编写测试，是专为与服务界面交互类是有用的。这比使用标准Django测试客户端要严格一些，因为这意味着所有交互都应通过API进行。

如果您正在使用`RequestsClient`，则需要确保测试设置和结果断言是作为常规API调用执行的，而不是直接与数据库模型进行交互。例如，与其检查`Customer.objects.count() == 3`您将列出客户终结点，并确保它包含三个记录，而不是检查。

## [标头和身份验证](https://www.django-rest-framework.org/api-guide/testing/#headers-authentication)

可以使用与[使用标准`requests.Session`实例](http://docs.python-requests.org/en/master/user/advanced/#session-objects)相同的方式来提供自定义标头和身份验证凭据。

```
from requests.auth import HTTPBasicAuth

client.auth = HTTPBasicAuth('user', 'pass')
client.headers.update({'x-test': 'true'})
```

## [CSRF](https://www.django-rest-framework.org/api-guide/testing/#csrf)

如果你使用的`SessionAuthentication`，那么你就需要包括令牌任何一个CSRF `POST`，`PUT`，`PATCH`或`DELETE`请求。

您可以按照基于JavaScript的客户端将使用的相同流程进行操作。首先发出`GET`请求以获取CRSF令牌，然后在随后的请求中出示该令牌。

例如...

```
client = RequestsClient()

# Obtain a CSRF token.
response = client.get('http://testserver/homepage/')
assert response.status_code == 200
csrftoken = response.cookies['csrftoken']

# Interact with the API.
response = client.post('http://testserver/organisations/', json={
    'name': 'MegaCorp',
    'status': 'active'
}, headers={'X-CSRFToken': csrftoken})
assert response.status_code == 200
```

## [现场测试](https://www.django-rest-framework.org/api-guide/testing/#live-tests)

通过仔细使用，`RequestsClient`和`CoreAPIClient`提供了编写测试用例的能力，这些用例可以在开发中运行，也可以直接在登台服务器或生产环境中运行。

使用此样式创建一些核心功能的基本测试是验证实时服务的有效方法。这样做可能需要仔细注意设置和拆卸，以确保测试以不会直接影响客户数据的方式运行。

------

# [CoreAPIClient](https://www.django-rest-framework.org/api-guide/testing/#coreapiclient)

CoreAPIClient允许您使用Python `coreapi`客户端库与您的API进行交互 。

```
# Fetch the API schema
client = CoreAPIClient()
schema = client.get('http://testserver/schema/')

# Create a new organisation
params = {'name': 'MegaCorp', 'status': 'active'}
client.action(schema, ['organisations', 'create'], params)

# Ensure that the organisation exists in the listing
data = client.action(schema, ['organisations', 'list'])
assert(len(data) == 1)
assert(data == [{'name': 'MegaCorp', 'status': 'active'}])
```

## [标头和身份验证](https://www.django-rest-framework.org/api-guide/testing/#headers-authentication_1)

自定义标头和身份验证的使用`CoreAPIClient`方式与相似`RequestsClient`。

```
from requests.auth import HTTPBasicAuth

client = CoreAPIClient()
client.session.auth = HTTPBasicAuth('user', 'pass')
client.session.headers.update({'x-test': 'true'})
```

------

# [API测试用例](https://www.django-rest-framework.org/api-guide/testing/#api-test-cases)

REST框架包括以下测试用例类，它们反映了现有的Django测试用例类，但使用`APIClient`而不是Django的default `Client`。

- `APISimpleTestCase`
- `APITransactionTestCase`
- `APITestCase`
- `APILiveServerTestCase`

## [例](https://www.django-rest-framework.org/api-guide/testing/#example)

您可以像使用常规Django测试用例类一样使用REST框架的任何用例类。该`self.client`属性将是一个`APIClient`实例。

```
from django.urls import reverse
from rest_framework import status
from rest_framework.test import APITestCase
from myproject.apps.core.models import Account

class AccountTests(APITestCase):
    def test_create_account(self):
        """
        Ensure we can create a new account object.
        """
        url = reverse('account-list')
        data = {'name': 'DabApps'}
        response = self.client.post(url, data, format='json')
        self.assertEqual(response.status_code, status.HTTP_201_CREATED)
        self.assertEqual(Account.objects.count(), 1)
        self.assertEqual(Account.objects.get().name, 'DabApps')
```

------

# [URLPatternsTestCase](https://www.django-rest-framework.org/api-guide/testing/#urlpatternstestcase)

REST框架还提供了一个测试用例类，`urlpatterns`以基于每个类进行隔离。请注意，这继承自Django的`SimpleTestCase`，很可能需要与另一个测试用例类混合使用。

## [例](https://www.django-rest-framework.org/api-guide/testing/#example_1)

```
from django.urls import include, path, reverse
from rest_framework.test import APITestCase, URLPatternsTestCase


class AccountTests(APITestCase, URLPatternsTestCase):
    urlpatterns = [
        path('api/', include('api.urls')),
    ]

    def test_create_account(self):
        """
        Ensure we can create a new account object.
        """
        url = reverse('account-list')
        response = self.client.get(url, format='json')
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(len(response.data), 1)
```

------

# [测试回应](https://www.django-rest-framework.org/api-guide/testing/#testing-responses)

## [检查响应数据](https://www.django-rest-framework.org/api-guide/testing/#checking-the-response-data)

在检查测试响应的有效性时，通常更方便的方法是检查创建响应的数据，而不是检查完全呈现的响应。

例如，检查起来更容易`response.data`：

```
response = self.client.get('/users/4/')
self.assertEqual(response.data, {'id': 4, 'username': 'lauren'})
```

而不是检查解析结果`response.content`：

```
response = self.client.get('/users/4/')
self.assertEqual(json.loads(response.content), {'id': 4, 'username': 'lauren'})
```

## [渲染回应](https://www.django-rest-framework.org/api-guide/testing/#rendering-responses)

如果您直接使用来测试视图`APIRequestFactory`，则返回的响应将尚未呈现，因为模板响应的呈现是由Django的内部请求-响应周期执行的。为了进行访问`response.content`，您首先需要呈现响应。

```
view = UserDetail.as_view()
request = factory.get('/users/4')
response = view(request, pk='4')
response.render()  # Cannot access `response.content` without this.
self.assertEqual(response.content, '{"username": "lauren", "id": 4}')
```

------

# [组态](https://www.django-rest-framework.org/api-guide/testing/#configuration)

## [设置默认格式](https://www.django-rest-framework.org/api-guide/testing/#setting-the-default-format)

可以使用`TEST_REQUEST_DEFAULT_FORMAT`设置键设置用于发出测试请求的默认格式。例如，要始终在默认情况下始终对测试请求使用JSON而不是标准的多部分表单请求，请在`settings.py`文件中设置以下内容：

```
REST_FRAMEWORK = {
    ...
    'TEST_REQUEST_DEFAULT_FORMAT': 'json'
}
```

## [设置可用格式](https://www.django-rest-framework.org/api-guide/testing/#setting-the-available-formats)

如果您需要使用multipart或json请求之外的其他测试请求，则可以通过设置`TEST_REQUEST_RENDERER_CLASSES`设置来进行。

例如，要增加对`format='html'`在测试请求中使用的支持，您的`settings.py`文件中可能会有类似的内容。

```
REST_FRAMEWORK = {
    ...
    'TEST_REQUEST_RENDERER_CLASSES': [
        'rest_framework.renderers.MultiPartRenderer',
        'rest_framework.renderers.JSONRenderer',
        'rest_framework.renderers.TemplateHTMLRenderer'
    ]
}
```