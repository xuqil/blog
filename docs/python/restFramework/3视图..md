# [基于类的视图](https://www.django-rest-framework.org/api-guide/views/#class-based-views)

> Django的基于类的视图是对旧式视图的欢迎。
>
> — [Reinout van Rees](https://reinout.vanrees.org/weblog/2011/08/24/class-based-views-usage.html)

REST框架提供了一个`APIView`类，该类继承了Django的`View`类。

`APIView`类与常规`View`类在以下方面有所不同：

- 传递给处理程序方法的请求将是REST框架的`Request`实例，而不是Django的`HttpRequest`实例。
- 处理程序方法可能返回REST框架的`Response`而不是Django的`HttpResponse`。该视图将管理内容协商并在响应上设置正确的渲染器。
- 任何`APIException`异常都将被捕获并调解为适当的响应。
- 在将请求分派到处理程序方法之前，将对传入的请求进行身份验证并进行适当的权限和/或限制检查。

使用`APIView`该类与使用常规`View`类几乎相同，通常，传入的请求将分派到适当的处理程序方法，例如`.get()`或`.post()`。另外，可以在控制API策略各个方面的类上设置许多属性。

例如：

```python
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import authentication, permissions
from django.contrib.auth.models import User

class ListUsers(APIView):
    """
    View to list all users in the system.

    * Requires token authentication.
    * Only admin users are able to access this view.
    """
    authentication_classes = [authentication.TokenAuthentication]
    permission_classes = [permissions.IsAdminUser]

    def get(self, request, format=None):
        """
        Return a list of all users.
        """
        usernames = [user.username for user in User.objects.all()]
        return Response(usernames)
```

------

**注**：完整的方法，属性，并与Django的REST框架的关系`APIView`，`GenericAPIView`各种`Mixins`，并且`Viewsets`可以初步复杂。除了此处的文档外，[Classy Django REST Framework](http://www.cdrf.co/)资源还为每个Django REST Framework基于类的视图提供了可浏览的参考，以及完整的方法和属性。

------

## [API策略属性](https://www.django-rest-framework.org/api-guide/views/#api-policy-attributes)

以下属性控制API视图的可插入方面。

### [.renderer_classes](https://www.django-rest-framework.org/api-guide/views/#renderer_classes)

### [.parser_classes](https://www.django-rest-framework.org/api-guide/views/#parser_classes)

### [.authentication_classes](https://www.django-rest-framework.org/api-guide/views/#authentication_classes)

### [.throttle_classes](https://www.django-rest-framework.org/api-guide/views/#throttle_classes)

### [.permission_classes](https://www.django-rest-framework.org/api-guide/views/#permission_classes)

### [.content_negotiation_class](https://www.django-rest-framework.org/api-guide/views/#content_negotiation_class)

## [API策略实例化方法](https://www.django-rest-framework.org/api-guide/views/#api-policy-instantiation-methods)

REST框架使用以下方法来实例化各种可插拔API策略。您通常不需要重写这些方法。

### [.get_renderers(self)](https://www.django-rest-framework.org/api-guide/views/#get_renderersself)

### [.get_parsers(self)](https://www.django-rest-framework.org/api-guide/views/#get_parsersself)

### [.get_authenticators(self)](https://www.django-rest-framework.org/api-guide/views/#get_authenticatorsself)

### [.get_throttles(self)](https://www.django-rest-framework.org/api-guide/views/#get_throttlesself)

### [.get_permissions(self)](https://www.django-rest-framework.org/api-guide/views/#get_permissionsself)

### [.get_content_negotiator(self)](https://www.django-rest-framework.org/api-guide/views/#get_content_negotiatorself)

### [.get_exception_handler(self)](https://www.django-rest-framework.org/api-guide/views/#get_exception_handlerself)

## [API策略实施方法](https://www.django-rest-framework.org/api-guide/views/#api-policy-implementation-methods)

在分派到处理程序方法之前，将调用以下方法。

### [.check_permissions(self, request)](https://www.django-rest-framework.org/api-guide/views/#check_permissionsself-request)

### [.check_throttles(self, request)](https://www.django-rest-framework.org/api-guide/views/#check_throttlesself-request)

### [.perform_content_negotiation(self, request, force=False)](https://www.django-rest-framework.org/api-guide/views/#perform_content_negotiationself-request-forcefalse)

## [Dispatch 方法](https://www.django-rest-framework.org/api-guide/views/#dispatch-methods)

视图的`.dispatch()`方法直接调用以下方法。这些执行需要之前或调用处理方法，如之后发生的任何动作`.get()`，`.post()`，`put()`，`patch()`和`.delete()`。

### [.initial(self, request, *args, **kwargs)](https://www.django-rest-framework.org/api-guide/views/#initialself-request-42args-kwargs)

执行在调用处理程序方法之前需要执行的所有操作。此方法用于强制执行权限和限制，并执行内容协商。

您通常不需要重写此方法。

### [.handle_exception(self, exc)](https://www.django-rest-framework.org/api-guide/views/#handle_exceptionself-exc)

处理程序方法引发的任何异常都将传递给此方法，该方法将返回一个`Response`实例，或重新引发该异常。

默认实现处理的任何子类`rest_framework.exceptions.APIException`以及Django的`Http404`和`PermissionDenied`异常，并返回适当的错误响应。

如果您需要自定义错误响应，那么您的API返回的值应该子类化此方法。

### [.initialize_request(self, request, *args, **kwargs)](https://www.django-rest-framework.org/api-guide/views/#initialize_requestself-request-42args-kwargs)

确保传递给处理程序方法的请求对象是的实例`Request`，而不是通常的Django `HttpRequest`。

您通常不需要重写此方法。

### [.finalize_response(self, request, response, *args, **kwargs)](https://www.django-rest-framework.org/api-guide/views/#finalize_responseself-request-response-42args-kwargs)

确保`Response`从处理程序方法返回的任何对象都将呈现为正确的内容类型，这由内容协商确定。

您通常不需要重写此方法。

------

# [基于函数的视图](https://www.django-rest-framework.org/api-guide/views/#function-based-views)

> 说[基于类的视图]始终是最佳解决方案，这是一个错误。
>
> — [尼克·科格兰](http://www.boredomandlaziness.org/2012/05/djangos-cbvs-are-not-mistake-but.html)

REST框架还允许您使用基于常规函数的视图。它提供了一组简单的装饰器，包装了基于函数的视图，以确保它们接收的实例`Request`（而不是通常的Django `HttpRequest`），并允许它们返回`Response`（而不是Django `HttpResponse`），并允许您配置如何处理请求。

## [@api_view（）](https://www.django-rest-framework.org/api-guide/views/#api_view)

**签名：** `@api_view(http_method_names=['GET'])`

该功能的核心是`api_view`装饰器，该装饰器列出了视图应响应的HTTP方法的列表。例如，这是您编写一个非常简单的视图的方式，只需手动返回一些数据即可：

```python
from rest_framework.decorators import api_view

@api_view()
def hello_world(request):
    return Response({"message": "Hello, world!"})
```

该视图将使用[设置中](https://www.django-rest-framework.org/api-guide/settings/)指定的默认渲染器，解析器，身份验证类等。

默认情况下，只`GET`接受方法。其他方法将响应“ 405方法不允许”。要更改此行为，请指定视图允许的方法，如下所示：

```python
@api_view(['GET', 'POST'])
def hello_world(request):
    if request.method == 'POST':
        return Response({"message": "Got some data!", "data": request.data})
    return Response({"message": "Hello, world!"})
```

## [API策略装饰器](https://www.django-rest-framework.org/api-guide/views/#api-policy-decorators)

要覆盖默认设置，REST框架提供了一组其他装饰器，可以将其添加到视图中。这些必须在装饰器`@api_view`*之后*（下方）进行。例如，要创建使用[throttle](https://www.django-rest-framework.org/api-guide/throttling/) 来确保特定用户每天只能调用一次的视图，请使用`@throttle_classes`装饰器，并传递油门类列表：

```python
from rest_framework.decorators import api_view, throttle_classes
from rest_framework.throttling import UserRateThrottle

class OncePerDayUserThrottle(UserRateThrottle):
        rate = '1/day'

@api_view(['GET'])
@throttle_classes([OncePerDayUserThrottle])
def view(request):
    return Response({"message": "Hello for today! See you tomorrow!"})
```

这些装饰器对应于`APIView`如上所述在子类上设置的属性。

可用的装饰器是：

- `@renderer_classes(...)`
- `@parser_classes(...)`
- `@authentication_classes(...)`
- `@throttle_classes(...)`
- `@permission_classes(...)`

这些装饰器中的每一个都带有一个参数，该参数必须是类的列表或元组。

## [视图架构装饰器](https://www.django-rest-framework.org/api-guide/views/#view-schema-decorator)

要覆盖基于函数的视图的默认架构生成，可以使用`@schema`装饰器。这必须在装饰器`@api_view`*之后*（下方）进行。例如：

```python
from rest_framework.decorators import api_view, schema
from rest_framework.schemas import AutoSchema

class CustomAutoSchema(AutoSchema):
    def get_link(self, path, method, base_url):
        # override view introspection here...

@api_view(['GET'])
@schema(CustomAutoSchema())
def view(request):
    return Response({"message": "Hello for today! See you tomorrow!"})
```

该装饰器采用一个`AutoSchema`实例，一个`AutoSchema`子类实例或[Schemas文档](https://www.django-rest-framework.org/api-guide/schemas/)`ManualSchema`中所述的实例。您可以通过以将视图从架构生成中排除。`None`

```python
@api_view(['GET'])
@schema(None)
def view(request):
    return Response({"message": "Will not appear in schema!"})
```