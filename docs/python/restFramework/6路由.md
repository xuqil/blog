# [Routers](https://www.django-rest-framework.org/api-guide/routers/#routers)

> 资源路由允许您快速声明给定资源控制器的所有通用路由。无需为索引声明单独的路由，而是在单行代码中声明资源丰富的路由。
>
> — [Ruby on Rails文档](https://guides.rubyonrails.org/routing.html)

一些Web框架（例如Rails）提供了自动确定应用程序的URL应如何映射到处理传入请求的逻辑的功能。

REST框架增加了对将自动URL路由到Django的支持，并为您提供了一种简单，快速且一致的方式将视图逻辑连接到一组URL。

## [用法](https://www.django-rest-framework.org/api-guide/routers/#usage)

这是一个使用的简单URL conf的示例`SimpleRouter`。

```python
from rest_framework import routers

router = routers.SimpleRouter()
router.register(r'users', UserViewSet)
router.register(r'accounts', AccountViewSet)
urlpatterns = router.urls
```

该方法有两个强制性参数`register()`：

- `prefix` -用于这组路由的URL前缀。
- `viewset` -视图集类。

（可选）您还可以指定其他参数：

- `basename`-用于创建的URL名称的基础。如果未设置，则基名称将基于`queryset`视图集的属性自动生成（如果有）。请注意，如果视图集不包含`queryset`属性，则必须`basename`在注册视图集时进行设置。

上面的示例将生成以下URL模式：

- 网址格式：`^users/$` 名称：`'user-list'`
- 网址格式：`^users/{pk}/$` 名称：`'user-detail'`
- 网址格式：`^accounts/$` 名称：`'account-list'`
- 网址格式：`^accounts/{pk}/$` 名称：`'account-detail'`

------

**注意**：该`basename`参数用于指定视图名称模式的初始部分。在上面的示例中，这就是“ `user`或” `account`部分。

通常，您*不需要*指定`basename`参数，但是如果您有一个定义了自定义`get_queryset`方法的视图`.queryset`集，则该视图集可能没有属性集。如果尝试注册该视图集，则会看到类似以下错误：

```python
'basename' argument not specified, and could not automatically determine the name from the viewset, as it does not have a '.queryset' attribute.
```

这意味着`basename`注册视图集时需要显式设置参数，因为无法从模型名称自动确定该参数。

------

### [`include`与路由器一起使用](https://www.django-rest-framework.org/api-guide/routers/#using-include-with-routers)

`.urls`路由器实例上的属性只是URL模式的标准列表。关于如何包含这些URL，有很多不同的样式。

例如，您可以追加`router.urls`到现有视图的列表中...

```python
router = routers.SimpleRouter()
router.register(r'users', UserViewSet)
router.register(r'accounts', AccountViewSet)

urlpatterns = [
    url(r'^forgot-password/$', ForgotPasswordFormView.as_view()),
]

urlpatterns += router.urls
```

另外，您也可以使用Django的`include`功能，例如...

```python
urlpatterns = [
    url(r'^forgot-password/$', ForgotPasswordFormView.as_view()),
    url(r'^', include(router.urls)),
]
```

您可以使用`include`应用程序名称空间：

```python
urlpatterns = [
    url(r'^forgot-password/$', ForgotPasswordFormView.as_view()),
    url(r'^api/', include((router.urls, 'app_name'))),
]
```

或应用程序和实例名称空间：

```python
urlpatterns = [
    url(r'^forgot-password/$', ForgotPasswordFormView.as_view()),
    url(r'^api/', include((router.urls, 'app_name'), namespace='instance_name')),
]
```

有关更多详细信息，请参见Django的[URL名称空间文档](https://docs.djangoproject.com/en/3.0/topics/http/urls/)和[`include`API参考](https://docs.djangoproject.com/en/2.0/ref/urls/#include)。

------

**注意**：如果将命名空间与超链接的序列化程序一起使用，则还需要确保`view_name`序列化程序上的所有参数都能正确反映名称空间。在上面的示例中，您需要包括一个参数，例如`view_name='app_name:user-detail'`超链接到用户详细信息视图的序列化程序字段的参数 。

自动`view_name`生成使用的模式`%(model_name)-detail`。除非您的模型名称实际发生冲突，否则在使用超链接序列化程序时最好**不要为** Django REST Framework视图命名。

------

### [额外操作的路由](https://www.django-rest-framework.org/api-guide/routers/#routing-for-extra-actions)

视图集可以通过用装饰器装饰方法来[标记用于路由](https://www.django-rest-framework.org/api-guide/viewsets/#marking-extra-actions-for-routing)的[额外操作](https://www.django-rest-framework.org/api-guide/viewsets/#marking-extra-actions-for-routing)`@action`。这些额外的动作将包含在生成的路线中。例如，给定类的`set_password`方法`UserViewSet`：

```python
from myapp.permissions import IsAdminOrIsSelf
from rest_framework.decorators import action

class UserViewSet(ModelViewSet):
    ...

    @action(methods=['post'], detail=True, permission_classes=[IsAdminOrIsSelf])
    def set_password(self, request, pk=None):
        ...
```

将生成以下路线：

- 网址格式： `^users/{pk}/set_password/$`
- 网址名称： `'user-set-password'`

默认情况下，URL模式基于方法命名，URL名称是`ViewSet.basename`和连字符方法名的组合。如果您不想对这些值中的任何一个使用默认值，您可以改为向`@action` 装饰器提供`url_path`和 `url_name`参数。

例如，如果要将我们的自定义操作的URL更改为`^users/{pk}/change-password/$`，则可以编写：

```python
from myapp.permissions import IsAdminOrIsSelf
from rest_framework.decorators import action

class UserViewSet(ModelViewSet):
    ...

    @action(methods=['post'], detail=True, permission_classes=[IsAdminOrIsSelf],
            url_path='change-password', url_name='change_password')
    def set_password(self, request, pk=None):
        ...
```

上面的示例现在将生成以下URL模式：

- 网址路径： `^users/{pk}/change-password/$`
- 网址名称： `'user-change_password'`

# [API指南](https://www.django-rest-framework.org/api-guide/routers/#api-guide)

## [SimpleRouter](https://www.django-rest-framework.org/api-guide/routers/#simplerouter)

该路由器包括一套标准的途径`list`，`create`，`retrieve`，`update`，`partial_update`和`destroy`行动。视图集还可以使用`@action`装饰器标记路由的其他方法。

| URL Style                     | HTTP Method                | Action                                   | URL Name              |
| ----------------------------- | -------------------------- | ---------------------------------------- | --------------------- |
| {prefix}/                     | GET                        | list                                     | {basename}-list       |
| POST                          | create                     |                                          |                       |
| {prefix}/{url_path}/          | GET, 或由`methods`参数指定 | `@action(detail=False)` decorated method | {basename}-{url_name} |
| {prefix}/{lookup}/            | GET                        | retrieve                                 | {basename}-detail     |
| PUT                           | update                     |                                          |                       |
| PATCH                         | partial_update             |                                          |                       |
| DELETE                        | destroy                    |                                          |                       |
| {prefix}/{lookup}/{url_path}/ | GET, 或由`methods`参数指定 | `@action(detail=True)` decorated method  | {basename}-{url_name} |

默认情况下，`SimpleRoute`r创建的url会附加一个斜杠。在实例化路由器时，可以通过将尾部的斜杠参数设置为`False`来修改此行为。例如：

```python
router = SimpleRouter(trailing_slash=False)
```

尾部的斜杠在Django中是常规的，但在其他一些框架（例如Rails）中默认不使用。尽管有些JavaScript框架可能期望使用特定的路由样式，但是选择使用哪种样式在很大程度上取决于首选项。

路由器将匹配包含除斜杠和句点字符以外的任何字符的查找值。对于更严格（或更宽松）的查找模式，请`lookup_value_regex`在视图集上设置属性。例如，您可以将查找限制为有效的UUID：

```python
class MyModelViewSet(mixins.RetrieveModelMixin, viewsets.GenericViewSet):
    lookup_field = 'my_model_id'
    lookup_value_regex = '[0-9a-f]{32}'
```

## [DefaultRouter](https://www.django-rest-framework.org/api-guide/routers/#defaultrouter)

该路由器与`SimpleRouter`上面类似，但是还包括一个默认的API根视图，该根视图返回一个响应，其中包含指向所有列表视图的超链接。它还为可选`.json`样式格式后缀生成路由。

| URL Style                              | HTTP Method                | Action                                   | URL Name              |
| -------------------------------------- | -------------------------- | ---------------------------------------- | --------------------- |
| [.format]                              | GET                        | 自动生成的根视图                         | api-root              |
| {prefix}/[.format]                     | GET                        | list                                     | {basename}-list       |
| POST                                   | create                     |                                          |                       |
| {prefix}/{url_path}/[.format]          | GET, 或由“methods”参数指定 | `@action(detail=False)` decorated method | {basename}-{url_name} |
| {prefix}/{lookup}/[.format]            | GET                        | retrieve                                 | {basename}-detail     |
| PUT                                    | update                     |                                          |                       |
| PATCH                                  | partial_update             |                                          |                       |
| DELETE                                 | destroy                    |                                          |                       |
| {prefix}/{lookup}/{url_path}/[.format] | GET, 或由“methods”参数指定 | `@action(detail=True)` decorated method  | {basename}-{url_name} |

与`SimpleRouter`一样，在实例化路由器时，可以通过将`trailing_slash`参数设置为`False`来删除URL路由上的尾部斜杠。

```python
router = DefaultRouter(trailing_slash=False)
```

# [自定义路由器](https://www.django-rest-framework.org/api-guide/routers/#custom-routers)

实施定制路由器并不是您经常需要做的事情，但是如果您对API的URL的结构有特定要求，这将很有用。这样做可以使您以可重用的方式封装URL结构，从而确保您不必为每个新视图明确编写URL模式。

实现自定义路由器的最简单方法是将现有路由器类之一作为子类。该`.routes`属性用于模板化将映射到每个视图集的URL模式。该`.routes`属性是`Route`命名元组的列表。

`Route`命名元组的参数为：

**url**：一个字符串，代表要路由的URL。可能包含以下格式字符串：

- `{prefix}` -用于这组路由的URL前缀。
- `{lookup}` -用于与单个实例匹配的查找字段。
- `{trailing_slash}`-根据`trailing_slash`参数，是'/'还是空字符串。

**mapping**：HTTP方法名称到视图方法的映射

**name**：`reverse`呼叫中使用的URL名称。可能包含以下格式字符串：

- `{basename}` -用于创建的URL名称的基础。

**initkwargs**：实例化视图时应传递的所有其他参数的字典。请注意，`detail`，`basename`，和`suffix`参数保留给视图集中内省和也使用可浏览的API生成视图名称和面包屑链接。

## [自定义动态路线](https://www.django-rest-framework.org/api-guide/routers/#customizing-dynamic-routes)

您还可以自定义`@action`装饰器的路由方式。`DynamicRoute`在`.routes`列表中包括命名的元组，将`detail`参数设置为适用于基于列表的路由和基于详细信息的路由。除了`detail`，参数为`DynamicRoute`：

**url**：一个字符串，代表要路由的URL。可能包含与相同的格式字符串`Route`，并且另外接受`{url_path}`格式字符串。

**name**：`reverse`呼叫中使用的URL名称。可能包含以下格式字符串：

- `{basename}` -用于创建的URL名称的基础。
- `{url_name}`- `url_name`提供给`@action`。

**initkwargs**：实例化视图时应传递的所有其他参数的字典。

## [例](https://www.django-rest-framework.org/api-guide/routers/#example)

以下示例将仅路由到`list`和`retrieve`操作，并且不使用尾部斜杠约定。

```python
from rest_framework.routers import Route, DynamicRoute, SimpleRouter

class CustomReadOnlyRouter(SimpleRouter):
    """
    A router for read-only APIs, which doesn't use trailing slashes.
    """
    routes = [
        Route(
            url=r'^{prefix}$',
            mapping={'get': 'list'},
            name='{basename}-list',
            detail=False,
            initkwargs={'suffix': 'List'}
        ),
        Route(
            url=r'^{prefix}/{lookup}$',
            mapping={'get': 'retrieve'},
            name='{basename}-detail',
            detail=True,
            initkwargs={'suffix': 'Detail'}
        ),
        DynamicRoute(
            url=r'^{prefix}/{lookup}/{url_path}$',
            name='{basename}-{url_name}',
            detail=True,
            initkwargs={}
        )
    ]
```

让我们看一下我们`CustomReadOnlyRouter`将为简单视图集生成的路线。

`views.py`：

```python
class UserViewSet(viewsets.ReadOnlyModelViewSet):
    """
    A viewset that provides the standard actions
    """
    queryset = User.objects.all()
    serializer_class = UserSerializer
    lookup_field = 'username'

    @action(detail=True)
    def group_names(self, request, pk=None):
        """
        Returns a list of all the group names that the given
        user belongs to.
        """
        user = self.get_object()
        groups = user.groups.all()
        return Response([group.name for group in groups])
```

`urls.py`：

```python
router = CustomReadOnlyRouter()
router.register('users', UserViewSet)
urlpatterns = router.urls
```

将生成以下映射...

| URL                           | HTTP Method | Action      | URL Name         |
| ----------------------------- | ----------- | ----------- | ---------------- |
| /users                        | GET         | list        | user-list        |
| /users/{username}             | GET         | retrieve    | user-detail      |
| /users/{username}/group_names | GET         | group_names | user-group-names |

有关设置`.routes`属性的另一个示例，请参见`SimpleRouter`该类的源代码。

## [高级自定义路由器](https://www.django-rest-framework.org/api-guide/routers/#advanced-custom-routers)

如果要提供完全自定义的行为，则可以重写`BaseRouter`和重写该`get_urls(self)`方法。该方法应检查已注册的视图集并返回URL模式列表。可以通过访问`self.registry`属性来检查已注册的前缀，视图集和基本名称元组。

您可能还想覆盖该`get_default_basename(self, viewset)`方法，或者`basename`在向路由器注册视图集时始终显式设置参数。

# [第三方软件包](https://www.django-rest-framework.org/api-guide/routers/#third-party-packages)

以下第三方软件包也可用。

## [DRF嵌套路由器](https://www.django-rest-framework.org/api-guide/routers/#drf-nested-routers)

的[DRF-嵌套的路由器包](https://github.com/alanjds/drf-nested-routers)提供路由器和关系字段用于与嵌套资源工作。

## [ModelRouter（wq.db.rest）](https://www.django-rest-framework.org/api-guide/routers/#modelrouter-wqdbrest)

所述[wq.db包](https://wq.io/wq.db)提供了一个先进[ModelRouter](https://wq.io/docs/router)延伸类（和单个实例）`DefaultRouter`用`register_model()`的API。就像Django一样`admin.site.register`，唯一需要的参数`rest.router.register_model`是模型类。可以从模型和全局配置中推断出URL前缀，序列化程序和视图集的合理默认值。

```python
from wq.db import rest
from myapp.models import MyModel

rest.router.register_model(MyModel)
```

## [DRF扩展](https://www.django-rest-framework.org/api-guide/routers/#drf-extensions)

该[`DRF-extensions`软件包](https://chibisov.github.io/drf-extensions/docs/)提供了[路由器](https://chibisov.github.io/drf-extensions/docs/#routers)创建[嵌套viewsets](https://chibisov.github.io/drf-extensions/docs/#nested-routes)，[收藏级控制器](https://chibisov.github.io/drf-extensions/docs/#collection-level-controllers)与[定制的端点名](https://chibisov.github.io/drf-extensions/docs/#controller-endpoint-name)。