# [渲染器](https://www.django-rest-framework.org/api-guide/renderers/#renderers)

> 必须先呈现TemplateResponse实例，然后才能将其返回给客户端。呈现过程采用模板和上下文的中间表示，并将其转换为可以提供给客户端的最终字节流。
>
> — [Django文档](https://docs.djangoproject.com/en/stable/stable/template-response/#the-rendering-process)

REST框架包括许多内置的Renderer类，使您可以返回各种媒体类型的响应。还支持定义自己的自定义渲染器，这使您可以灵活地设计自己的媒体类型。

## [如何确定渲染器](https://www.django-rest-framework.org/api-guide/renderers/#how-the-renderer-is-determined)

视图的有效渲染器集始终定义为类列表。进入视图后，REST框架将对传入的请求执行内容协商，并确定最合适的渲染器以满足该请求。

内容协商的基本过程包括检查请求的`Accept`标头，以确定它在响应中期望的媒体类型。可选地，URL上的格式后缀可以用于显式请求特定的表示形式。例如，URL `http://example.com/api/users_count.json`可能是始终返回JSON数据的终结点。

有关更多信息，请参见有关[内容协商](https://www.django-rest-framework.org/api-guide/content-negotiation/)的文档。

## [设置渲染器](https://www.django-rest-framework.org/api-guide/renderers/#setting-the-renderers)

可以使用该`DEFAULT_RENDERER_CLASSES`设置全局设置默认渲染器集。例如，以下设置将`JSON`用作主要媒体类型，并且还包括自我描述API。

```python
REST_FRAMEWORK = {
    'DEFAULT_RENDERER_CLASSES': [
        'rest_framework.renderers.JSONRenderer',
        'rest_framework.renderers.BrowsableAPIRenderer',
    ]
}
```

您还可以使用`APIView`基于类的视图来设置用于单个视图或视图集的渲染器。

```python
from django.contrib.auth.models import User
from rest_framework.renderers import JSONRenderer
from rest_framework.response import Response
from rest_framework.views import APIView

class UserCountView(APIView):
    """
    A view that returns the count of active users in JSON.
    """
    renderer_classes = [JSONRenderer]

    def get(self, request, format=None):
        user_count = User.objects.filter(active=True).count()
        content = {'user_count': user_count}
        return Response(content)
```

或者，如果您将`@api_view`装饰器与基于函数的视图一起使用。

```python
@api_view(['GET'])
@renderer_classes([JSONRenderer])
def user_count_view(request, format=None):
    """
    A view that returns the count of active users in JSON.
    """
    user_count = User.objects.filter(active=True).count()
    content = {'user_count': user_count}
    return Response(content)
```

## [渲染器类的顺序](https://www.django-rest-framework.org/api-guide/renderers/#ordering-of-renderer-classes)

为API指定渲染器类时，考虑要分配给每种媒体类型的优先级很重要。如果客户端未指定其可以接受的表示形式，例如发送`Accept: */*`标头，或根本不包含`Accept`标头，则REST框架将选择列表中的第一个渲染器以用于响应。

例如，如果您的API提供JSON响应和HTML可浏览的API，则您可能希望使用`JSONRenderer`默认渲染器，以便将`JSON`响应发送给未指定`Accept`标头的客户端。

如果您的API包含可根据请求提供常规网页和API响应的视图，那么您可以考虑制作`TemplateHTMLRenderer`默认渲染器，以便与发送[破损接受标头的](http://www.gethifi.com/blog/browser-rest-http-accept-headers)旧版浏览器很好地配合使用。

------

# [API参考](https://www.django-rest-framework.org/api-guide/renderers/#api-reference)

## [JSONRenderer](https://www.django-rest-framework.org/api-guide/renderers/#jsonrenderer)

`JSON`使用utf-8编码将请求数据呈现为。

请注意，默认样式是包括unicode字符，并使用紧凑样式呈现响应，而没有不必要的空格：

```python
{"unicode black star":"★","value":999}
```

客户端可以另外包括`'indent'`媒体类型参数，在这种情况下，返回的内容`JSON`将缩进。例如`Accept: application/json; indent=4`。

```python
{
    "unicode black star": "★",
    "value": 999
}
```

可以使用`UNICODE_JSON`和`COMPACT_JSON`设置键更改默认的JSON编码样式。

**.media_type**：`application/json`

**.format**：`'json'`

**.charset**：`None`

## [TemplateHTMLRenderer](https://www.django-rest-framework.org/api-guide/renderers/#templatehtmlrenderer)

使用Django的标准模板渲染，将数据渲染为HTML。与其他渲染器不同，传递给的数据`Response`无需序列化。此外，与其他渲染器不同，您可能需要`template_name`在创建时包含一个参数`Response`。

TemplateHTMLRenderer将`RequestContext`使用`response.data`作为上下文字典创建一个，并确定用于呈现上下文的模板名称。

模板名称由（按优先顺序）确定：

1. 显式`template_name`参数传递给响应。
2. `.template_name`在此类上设置的显式属性。
3. 的返回结果`view.get_template_names()`。

使用`TemplateHTMLRenderer`以下视图的示例：

```python
class UserDetail(generics.RetrieveAPIView):
    """
    A view that returns a templated HTML representation of a given user.
    """
    queryset = User.objects.all()
    renderer_classes = [TemplateHTMLRenderer]

    def get(self, request, *args, **kwargs):
        self.object = self.get_object()
        return Response({'user': self.object}, template_name='user_detail.html')
```

您可以使用`TemplateHTMLRenderer`REST框架返回常规HTML页面，也可以从单个端点返回HTML和API响应。

如果要构建`TemplateHTMLRenderer`与其他渲染器类一起使用的网站，则应考虑将列表`TemplateHTMLRenderer`作为列表中的第一类`renderer_classes`，这样即使对于发送格式不正确的`ACCEPT:`标题的浏览器，它也将被优先排序。

有关用法的更多示例，请参见[*HTML＆Forms*主题页面](https://www.django-rest-framework.org/topics/html-and-forms/)`TemplateHTMLRenderer`。

**.media_type**：`text/html`

**.format**：`'html'`

**.charset**：`utf-8`

也可以看看： `StaticHTMLRenderer`

## [StaticHTMLRenderer](https://www.django-rest-framework.org/api-guide/renderers/#statichtmlrenderer)

一个简单的渲染器，仅返回预渲染的HTML。与其他渲染器不同，传递给响应对象的数据应为代表要返回内容的字符串。

使用`StaticHTMLRenderer`以下视图的示例：

```python
@api_view(['GET'])
@renderer_classes([StaticHTMLRenderer])
def simple_html_view(request):
    data = '<html><body><h1>Hello, world</h1></body></html>'
    return Response(data)
```

您可以使用`StaticHTMLRenderer`REST框架返回常规HTML页面，也可以从单个端点返回HTML和API响应。

**.media_type**：`text/html`

**.format**：`'html'`

**.charset**：`utf-8`

也可以看看： `TemplateHTMLRenderer`

## [BrowsableAPIRenderer](https://www.django-rest-framework.org/api-guide/renderers/#browsableapirenderer)

将数据呈现为可浏览API的HTML：

![BrowsableAPIRenderer](https://www.django-rest-framework.org/img/quickstart.png)

该渲染器将确定哪个其他渲染器将被赋予最高优先级，并使用该渲染器在HTML页面内显示API样式响应。

**.media_type**：`text/html`

**.format**：`'api'`

**.charset**：`utf-8`

**.template**：`'rest_framework/api.html'`

#### [自定义BrowsableAPIRenderer](https://www.django-rest-framework.org/api-guide/renderers/#customizing-browsableapirenderer)

默认情况下，响应内容将使用优先级最高的渲染器进行渲染`BrowsableAPIRenderer`。如果您需要自定义此行为，例如使用HTML作为默认返回格式，但在可浏览的API中使用JSON，则可以通过重写`get_default_renderer()`方法来实现。例如：

```python
class CustomBrowsableAPIRenderer(BrowsableAPIRenderer):
    def get_default_renderer(self, view):
        return JSONRenderer()
```

## [管理员呈现器](https://www.django-rest-framework.org/api-guide/renderers/#adminrenderer)

将数据呈现为HTML以进行类似管理员的显示：

![AdminRender视图](https://www.django-rest-framework.org/img/admin.png)

该渲染器适用于CRUD样式的Web API，这些API也应提供用户友好的界面来管理数据。

请注意，带有嵌套或列出序列化程序作为其输入的视图将不适用于`AdminRenderer`，因为HTML表单无法正确支持它们。

**注意**：`AdminRenderer`仅当数据中存在正确配置的`URL_FIELD_NAME`（`url`默认情况下）属性时，才能够包括指向详细信息页面的链接。对于`HyperlinkedModelSerializer`这种情况，但是对于`ModelSerializer`普通`Serializer`类，则需要确保明确包含该字段。例如，在这里我们使用模型`get_absolute_url`方法：

```python
class AccountSerializer(serializers.ModelSerializer):
    url = serializers.CharField(source='get_absolute_url', read_only=True)

    class Meta:
        model = Account
```

**.media_type**：`text/html`

**.format**：`'admin'`

**.charset**：`utf-8`

**.template**：`'rest_framework/admin.html'`

## [HTMLFormRenderer](https://www.django-rest-framework.org/api-guide/renderers/#htmlformrenderer)

将序列化程序返回的数据呈现为HTML格式。该渲染器的输出不包含封闭``标签，隐藏的CSRF输入或任何提交按钮。

不能直接使用此渲染器，而是可以通过将序列化器实例传递给`render_form`template标签在模板中使用。

```python
{% load rest_framework %}

<form action="/submit-report/" method="post">
    {% csrf_token %}
    {% render_form serializer %}
    <input type="submit" value="Save" />
</form>
```

有关更多信息，请参见[HTML＆Forms](https://www.django-rest-framework.org/topics/html-and-forms/)文档。

**.media_type**：`text/html`

**.format**：`'form'`

**.charset**：`utf-8`

**.template**：`'rest_framework/horizontal/form.html'`

## [MultiPartRenderer](https://www.django-rest-framework.org/api-guide/renderers/#multipartrenderer)

该渲染器用于渲染HTML多部分表单数据。 **它不适合用作响应呈现器**，而是用于使用REST框架的[测试客户端和测试请求工厂](https://www.django-rest-framework.org/api-guide/testing/)创建测试请求。

**.media_type**：`multipart/form-data; boundary=BoUnDaRyStRiNg`

**.format**：`'multipart'`

**.charset**：`utf-8`

------

# [自定义渲染器](https://www.django-rest-framework.org/api-guide/renderers/#custom-renderers)

要实现自定义渲染器，您应该重写`BaseRenderer`，设置`.media_type`和`.format`属性，并实现`.render(self, data, media_type=None, renderer_context=None)`方法。

该方法应返回一个字节串，它将用作HTTP响应的主体。

传递给该`.render()`方法的参数为：

### [`data`](https://www.django-rest-framework.org/api-guide/renderers/#data)

由`Response()`实例设置的请求数据。

### [`media_type=None`](https://www.django-rest-framework.org/api-guide/renderers/#media_typenone)

可选的。如果提供的话，这是由内容协商阶段确定的可接受的媒体类型。

根据客户端的`Accept:`标头，它可能比渲染器的`media_type`属性更具体，并且可能包括媒体类型参数。例如`"application/json; nested=true"`。

### [`renderer_context=None`](https://www.django-rest-framework.org/api-guide/renderers/#renderer_contextnone)

可选的。如果提供的话，这是视图提供的上下文信息的字典。

默认情况下，这将包括以下键：`view`，`request`，`response`，`args`，`kwargs`。

## [例](https://www.django-rest-framework.org/api-guide/renderers/#example)

以下是一个示例纯文本呈现器，它将返回带有`data`参数作为响应内容的响应。

```python
from django.utils.encoding import smart_unicode
from rest_framework import renderers


class PlainTextRenderer(renderers.BaseRenderer):
    media_type = 'text/plain'
    format = 'txt'

    def render(self, data, media_type=None, renderer_context=None):
        return data.encode(self.charset)
```

## [设置字符集](https://www.django-rest-framework.org/api-guide/renderers/#setting-the-character-set)

默认情况下，假定渲染器类正在使用`UTF-8`编码。要使用其他编码，请`charset`在渲染器上设置属性。

```python
class PlainTextRenderer(renderers.BaseRenderer):
    media_type = 'text/plain'
    format = 'txt'
    charset = 'iso-8859-1'

    def render(self, data, media_type=None, renderer_context=None):
        return data.encode(self.charset)
```

请注意，如果渲染器类返回unicode字符串，则该类将响应内容强制转换为字节串，并且在渲染器上设置`Response`的`charset`属性用于确定编码。

如果渲染器返回表示原始二进制内容的字节串，则应将字符集值设置为`None`，这将确保`Content-Type`响应的标头没有`charset`设置值。

在某些情况下，您可能还需要将`render_style`属性设置为`'binary'`。这样做还可以确保可浏览的API不会尝试将二进制内容显示为字符串。

```python
class JPEGRenderer(renderers.BaseRenderer):
    media_type = 'image/jpeg'
    format = 'jpg'
    charset = None
    render_style = 'binary'

    def render(self, data, media_type=None, renderer_context=None):
        return data
```

------

# [高级渲染器用法](https://www.django-rest-framework.org/api-guide/renderers/#advanced-renderer-usage)

您可以使用REST框架的渲染器来做一些非常灵活的事情。一些例子...

- 根据请求的媒体类型，从同一端点提供平面或嵌套表示。
- 提供来自相同端点的常规HTML网页和基于JSON的API响应。
- 为API客户端指定多种类型的HTML表示形式。
- 未充分指定渲染器的媒体类型，例如使用`media_type = 'image/*'`，并使用`Accept`标头更改响应的编码。

## [不同媒体类型的行为](https://www.django-rest-framework.org/api-guide/renderers/#varying-behaviour-by-media-type)

在某些情况下，您可能希望视图根据接受的媒体类型使用不同的序列化样式。如果需要执行此操作，则可以访问`request.accepted_renderer`以确定将用于响应的协商的渲染器。

例如：

```python
@api_view(['GET'])
@renderer_classes([TemplateHTMLRenderer, JSONRenderer])
def list_users(request):
    """
    A view that can return JSON or HTML representations
    of the users in the system.
    """
    queryset = Users.objects.filter(active=True)

    if request.accepted_renderer.format == 'html':
        # TemplateHTMLRenderer takes a context dict,
        # and additionally requires a 'template_name'.
        # It does not require serialization.
        data = {'users': queryset}
        return Response(data, template_name='list_users.html')

    # JSONRenderer requires serialized data as normal.
    serializer = UserSerializer(instance=queryset)
    data = serializer.data
    return Response(data)
```

## [媒体类型指定不足](https://www.django-rest-framework.org/api-guide/renderers/#underspecifying-the-media-type)

在某些情况下，您可能希望渲染器提供多种媒体类型。在这种情况下，你可以underspecify媒体类型应该通过使用响应，`media_type`价值等`image/*`，或`*/*`。

如果您未指定渲染器的媒体类型，则应确保在返回响应时使用`content_type`属性明确指定媒体类型。例如：

```python
return Response(data, content_type='image/png')
```

## [设计媒体类型](https://www.django-rest-framework.org/api-guide/renderers/#designing-your-media-types)

对于许多Web API而言，`JSON`具有超链接关系的简单响应可能就足够了。如果要完全采用RESTful设计和[HATEOAS](http://timelessrepo.com/haters-gonna-hateoas)，则需要更详细地考虑媒体类型的设计和使用。

在[罗伊菲尔丁的话说](https://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven)，“一个REST API应该花费几乎所有的其描述努力在确定用于表示资源和推动应用程序状态的媒体类型（S），或在定义扩展的关系名称和/或支持超文本mark-为现有的标准媒体类型。”。

有关自定义媒体类型的良好示例，请参阅GitHub对自定义[application / vnd.github + json](https://developer.github.com/v3/media/)媒体类型的使用，以及Mike Amundsen的IANA批准的[application / vnd.collection + json](http://www.amundsen.com/media-types/collection/)基于JSON的超媒体。

## [HTML错误视图](https://www.django-rest-framework.org/api-guide/renderers/#html-error-views)

通常，无论是处理常规响应，还是处理由引发异常（例如`Http404`或`PermissionDenied`异常或的子类）引起的响应，渲染器的行为都相同`APIException`。

如果您使用或`TemplateHTMLRenderer`或`StaticHTMLRenderer`且引发了异常，则行为会略有不同，并反映[Django对错误视图的默认处理](https://docs.djangoproject.com/en/stable/topics/http/views/#customizing-error-views)。

由HTML渲染器引发和处理的异常将按优先级尝试使用以下方法之一进行渲染。

- 加载并渲染名为的模板`{status_code}.html`。
- 加载并渲染名为的模板`api_exception.html`。
- 呈现HTTP状态代码和文本，例如“ 404 Not Found”。

模板将使用`RequestContext`包含`status_code`和`details`键的进行渲染。

**注意**：如果`DEBUG=True`显示，则将显示Django的标准回溯错误页面，而不呈现HTTP状态代码和文本。

------

# [第三方套餐](https://www.django-rest-framework.org/api-guide/renderers/#third-party-packages)

以下第三方软件包也可用。

## [YAML](https://www.django-rest-framework.org/api-guide/renderers/#yaml)

[REST框架YAML](https://jpadilla.github.io/django-rest-framework-yaml/)提供了[YAML](http://www.yaml.org/)解析和渲染支持。它以前直接包含在REST框架程序包中，现在已作为第三方程序包受支持。

#### [安装与配置](https://www.django-rest-framework.org/api-guide/renderers/#installation-configuration)

使用pip安装。

```python
$ pip install djangorestframework-yaml
```

修改您的REST框架设置。

```python
REST_FRAMEWORK = {
    'DEFAULT_PARSER_CLASSES': [
        'rest_framework_yaml.parsers.YAMLParser',
    ],
    'DEFAULT_RENDERER_CLASSES': [
        'rest_framework_yaml.renderers.YAMLRenderer',
    ],
}
```

## [XML格式](https://www.django-rest-framework.org/api-guide/renderers/#xml)

[REST Framework XML](https://jpadilla.github.io/django-rest-framework-xml/)提供了一种简单的非正式XML格式。它以前直接包含在REST框架程序包中，现在已作为第三方程序包受支持。

#### [安装与配置](https://www.django-rest-framework.org/api-guide/renderers/#installation-configuration_1)

使用pip安装。

```
$ pip install djangorestframework-xml
```

修改您的REST框架设置。

```
REST_FRAMEWORK = {
    'DEFAULT_PARSER_CLASSES': [
        'rest_framework_xml.parsers.XMLParser',
    ],
    'DEFAULT_RENDERER_CLASSES': [
        'rest_framework_xml.renderers.XMLRenderer',
    ],
}
```

## [JSONP](https://www.django-rest-framework.org/api-guide/renderers/#jsonp)

[REST框架JSONP](https://jpadilla.github.io/django-rest-framework-jsonp/)提供JSONP渲染支持。它以前直接包含在REST框架程序包中，现在已作为第三方程序包受支持。

------

**警告**：如果您需要跨域AJAX请求，通常应该使用[CORS](https://www.w3.org/TR/cors/)的更现代方法作为的替代方法`JSONP`。有关更多详细信息，请参见[CORS文档](https://www.django-rest-framework.org/topics/ajax-csrf-cors/)。

该`jsonp`方法本质上是一种浏览器黑客，并且[仅适用于全局可读的API终结点](https://stackoverflow.com/questions/613962/is-jsonp-safe-to-use)，在该[终结点中](https://stackoverflow.com/questions/613962/is-jsonp-safe-to-use)，`GET`请求未经[身份](https://stackoverflow.com/questions/613962/is-jsonp-safe-to-use)验证并且不需要任何用户权限。

------

#### [安装与配置](https://www.django-rest-framework.org/api-guide/renderers/#installation-configuration_2)

使用pip安装。

```python
$ pip install djangorestframework-jsonp
```

修改您的REST框架设置。

```python
REST_FRAMEWORK = {
    'DEFAULT_RENDERER_CLASSES': [
        'rest_framework_jsonp.renderers.JSONPRenderer',
    ],
}
```

## [消息包](https://www.django-rest-framework.org/api-guide/renderers/#messagepack)

[MessagePack](https://msgpack.org/)是一种快速，高效的二进制序列化格式。 [Juan Riaza](https://github.com/juanriaza)维护[djangorestframework-msgpack](https://github.com/juanriaza/django-rest-framework-msgpack)软件包，该软件包为REST框架提供MessagePack渲染器和解析器支持。

## [XLSX（二进制电子表格端点）](https://www.django-rest-framework.org/api-guide/renderers/#xlsx-binary-spreadsheet-endpoints)

XLSX是世界上最受欢迎的二进制电子表格格式。[蒂姆·艾伦](https://github.com/flipperpa)的[沃顿商学院](https://github.com/wharton)保持[DRF-渲染，XLSX](https://github.com/wharton/drf-renderer-xlsx)，这使得端点作为使用OpenPyXL一个XLSX的电子表格，并允许客户端下载。可以基于每个视图设置电子表格的样式。

#### [安装与配置](https://www.django-rest-framework.org/api-guide/renderers/#installation-configuration_3)

使用pip安装。

```python
$ pip install drf-renderer-xlsx
```

修改您的REST框架设置。

```python
REST_FRAMEWORK = {
    ...

    'DEFAULT_RENDERER_CLASSES': [
        'rest_framework.renderers.JSONRenderer',
        'rest_framework.renderers.BrowsableAPIRenderer',
        'drf_renderer_xlsx.renderers.XLSXRenderer',
    ],
}
```

为了避免流传输的文件没有文件名（浏览器通常将其默认为文件名“ download”，没有扩展名），我们需要使用mixin覆盖`Content-Disposition`标头。如果未提供文件名，则默认为`export.xlsx`。例如：

```python
from rest_framework.viewsets import ReadOnlyModelViewSet
from drf_renderer_xlsx.mixins import XLSXFileMixin
from drf_renderer_xlsx.renderers import XLSXRenderer

from .models import MyExampleModel
from .serializers import MyExampleSerializer

class MyExampleViewSet(XLSXFileMixin, ReadOnlyModelViewSet):
    queryset = MyExampleModel.objects.all()
    serializer_class = MyExampleSerializer
    renderer_classes = [XLSXRenderer]
    filename = 'my_export.xlsx'
```

## [CSV](https://www.django-rest-framework.org/api-guide/renderers/#csv)

逗号分隔的值是纯文本格式的表格数据格式，可以轻松地导入电子表格应用程序中。[Mjumbe Poe](https://github.com/mjumbewu)维护[djangorestframework-csv](https://github.com/mjumbewu/django-rest-framework-csv)软件包，该软件包为REST框架提供CSV渲染器支持。

## [UltraJSON](https://www.django-rest-framework.org/api-guide/renderers/#ultrajson)

[UltraJSON](https://github.com/esnme/ultrajson)是经过优化的C JSON编码器，可以显着加快JSON渲染速度。[Jacob Haslehurst](https://github.com/hzy)维护了[drf-ujson-renderer](https://github.com/gizmag/drf-ujson-renderer)软件包，该软件包使用UJSON软件包实现JSON呈现。

## [CamelCase JSON](https://www.django-rest-framework.org/api-guide/renderers/#camelcase-json)

[djangorestframework-camel-case](https://github.com/vbabiy/djangorestframework-camel-case)提供REST框架[的驼峰式](https://github.com/vbabiy/djangorestframework-camel-case) JSON渲染器和解析器。这允许序列化程序使用Python样式的带下划线的字段名称，但在API中以Javascript样式的驼峰式大小写字段名称公开。它由[Vitaly Babiy](https://github.com/vbabiy)维护。

## [熊猫（CSV，Excel，PNG）](https://www.django-rest-framework.org/api-guide/renderers/#pandas-csv-excel-png)

[Django REST Pandas](https://github.com/wq/django-rest-pandas)提供了序列化器和渲染器，它们支持通过[Pandas](https://pandas.pydata.org/) DataFrame API进行其他数据处理和输出。Django REST Pandas包括用于Pandas样式CSV文件，Excel工作簿（包括`.xls`和`.xlsx`）以及许多[其他格式的](https://github.com/wq/django-rest-pandas#supported-formats)渲染器。它由[S. Andrew Sheppard](https://github.com/sheppard)作为[wq项目的](https://github.com/wq)一部分进行维护。

## [胶乳](https://www.django-rest-framework.org/api-guide/renderers/#latex)

[Rest Framework Latex](https://github.com/mypebble/rest-framework-latex)提供了一个渲染器，该渲染器使用Laulatex输出PDF。它由[Pebble（S / F软件）](https://github.com/mypebble)维护。