# [Serializers](https://www.django-rest-framework.org/api-guide/serializers/#serializers)

> 我们想解决扩展串行器的作用。但是，这不是一个小问题，需要进行认真的设计工作。
>
> — [Django用户组](https://groups.google.com/d/topic/django-users/sVFaOfQi4wY/discussion) Russell Keith-Magee

序列化器允许诸如查询集和模型实例复杂的数据转换为原生的Python数据类型，然后可以很容易地呈现为`JSON`，`XML`或其他内容类型。序列化器还提供反序列化功能，允许在首先验证输入数据之后将解析的数据转换回复杂类型。

REST框架中的序列化器的工作方式与Django `Form`和`ModelForm`类非常相似。我们提供了一个`Serializer`类，该类为您提供了一种强大的通用方法来控制响应的输出，还`ModelSerializer`提供了一个类，该类为创建用于处理模型实例和查询集的序列化器提供了有用的快捷方式。

## [声明序列化器](https://www.django-rest-framework.org/api-guide/serializers/#declaring-serializers)

让我们从创建一个简单的对象开始，我们可以将其用于示例目的：

```python
from datetime import datetime

class Comment(object):
    def __init__(self, email, content, created=None):
        self.email = email
        self.content = content
        self.created = created or datetime.now()

comment = Comment(email='leila@example.com', content='foo bar')
```

我们将声明一个序列化器，可用于序列化和反序列化与`Comment`对象相对应的数据。

声明序列化器看起来与声明表单非常相似：

```python
from rest_framework import serializers

class CommentSerializer(serializers.Serializer):
    email = serializers.EmailField()
    content = serializers.CharField(max_length=200)
    created = serializers.DateTimeField()
```

## [序列化对象](https://www.django-rest-framework.org/api-guide/serializers/#serializing-objects)

现在，我们可以使用`CommentSerializer`序列化评论或评论列表。同样，使用`Serializer`类看起来很像使用`Form`类。

```python
serializer = CommentSerializer(comment)
serializer.data
# {'email': 'leila@example.com', 'content': 'foo bar', 'created': '2016-01-27T15:17:10.375877'}
```

至此，我们已经将模型实例转换为Python本机数据类型。为了完成序列化过程，我们将数据渲染到中`json`。

```python
from rest_framework.renderers import JSONRenderer

json = JSONRenderer().render(serializer.data)
json
# b'{"email":"leila@example.com","content":"foo bar","created":"2016-01-27T15:17:10.375877"}'
```

## [反序列化对象](https://www.django-rest-framework.org/api-guide/serializers/#deserializing-objects)

反序列化是相似的。首先，我们将流解析为Python本机数据类型。

```python
import io
from rest_framework.parsers import JSONParser

stream = io.BytesIO(json)
data = JSONParser().parse(stream)
```

...然后我们将这些本机数据类型还原为经过验证的数据字典。

```python
serializer = CommentSerializer(data=data)
serializer.is_valid()
# True
serializer.validated_data
# {'content': 'foo bar', 'email': 'leila@example.com', 'created': datetime.datetime(2012, 08, 22, 16, 20, 09, 822243)}
```

## [保存实例](https://www.django-rest-framework.org/api-guide/serializers/#saving-instances)

如果我们希望能够基于经过验证的数据返回完整的对象实例，则需要实现`.create()`和`.update()`方法之一或两者。例如：

```python
class CommentSerializer(serializers.Serializer):
    email = serializers.EmailField()
    content = serializers.CharField(max_length=200)
    created = serializers.DateTimeField()

    def create(self, validated_data):
        return Comment(**validated_data)

    def update(self, instance, validated_data):
        instance.email = validated_data.get('email', instance.email)
        instance.content = validated_data.get('content', instance.content)
        instance.created = validated_data.get('created', instance.created)
        return instance
```

如果您的对象实例与Django模型相对应，则还需要确保这些方法将对象保存到数据库中。例如，如果`Comment`是Django模型，则方法可能如下所示：

```python
    def create(self, validated_data):
        return Comment.objects.create(**validated_data)

    def update(self, instance, validated_data):
        instance.email = validated_data.get('email', instance.email)
        instance.content = validated_data.get('content', instance.content)
        instance.created = validated_data.get('created', instance.created)
        instance.save()
        return instance
```

现在，在对数据进行反序列化时，我们可以`.save()`基于已验证的数据调用以返回对象实例。

```python
comment = serializer.save()
```

调用`.save()`将创建一个新实例，或更新一个现有实例，具体取决于在实例化序列化程序类时是否传递了一个现有实例：

```python
# .save() will create a new instance.
serializer = CommentSerializer(data=data)

# .save() will update the existing `comment` instance.
serializer = CommentSerializer(comment, data=data)
```

无论是`.create()`和`.update()`方法是可选的。根据序列化程序类的用例，您既可以实现它们之一，也可以两者都不实现。

#### [将其他属性传递给 `.save()`](https://www.django-rest-framework.org/api-guide/serializers/#passing-additional-attributes-to-save)

有时，您希望视图代码能够在保存实例时注入其他数据。这些附加数据可能包括诸如当前用户，当前时间或不属于请求数据一部分的任何其他信息。

您可以通过在调用时包含其他关键字参数来实现`.save()`。例如：

```python
serializer.save(owner=request.user)
```

调用`.create（）`或`.update（）`时，任何其他关键字参数都将包含在已验证的数据参数中。

#### [直接重写`.save()`](https://www.django-rest-framework.org/api-guide/serializers/#overriding-save-directly)

在某些情况下，`.create()`和`.update()`方法名称可能没有意义。例如，在联系表格中，我们可能没有创建新实例，而是发送了电子邮件或其他消息。

在这些情况下，您可能会选择`.save()`直接重写，因为它更具可读性和意义。

例如：

```python
class ContactForm(serializers.Serializer):
    email = serializers.EmailField()
    message = serializers.CharField()

    def save(self):
        email = self.validated_data['email']
        message = self.validated_data['message']
        send_email(from=email, message=message)
```

请注意，在上述情况下，我们现在必须`.validated_data`直接访问`serializer` 属性。

## [验证方式](https://www.django-rest-framework.org/api-guide/serializers/#validation)

反序列化数据时，您始终需要先调用，`is_valid()`然后再尝试访问经过验证的数据或保存对象实例。如果发生任何验证错误，则该`.errors`属性将包含一个字典，代表产生的错误消息。例如：

```python
serializer = CommentSerializer(data={'email': 'foobar', 'content': 'baz'})
serializer.is_valid()
# False
serializer.errors
# {'email': ['Enter a valid e-mail address.'], 'created': ['This field is required.']}
```

词典中的每个键将是字段名称，值将是与该字段相对应的任何错误消息的字符串列表。该`non_field_errors`（非字段错误）密钥也可能存在，并将列出所有常规验证错误。`non_field_errors`（非字段错误）密钥的名称可以使用`NON_FIELD_ERRORS_KEY`REST框架设置进行自定义。

对项目列表进行反序列化时，将以代表每个反序列化项目的字典列表的形式返回错误。

#### [在无效数据上引发异常](https://www.django-rest-framework.org/api-guide/serializers/#raising-an-exception-on-invalid-data)

该`.is_valid()`方法带有一个可选`raise_exception`标志，`serializers.ValidationError`如果存在验证错误，它将导致引发异常。

这些异常由REST框架提供的默认异常处理程序自动处理，并且将`HTTP 400 Bad Request`默认返回响应。

```python
# Return a 400 response if the data was invalid.
serializer.is_valid(raise_exception=True)
```

#### [Field-level验证](https://www.django-rest-framework.org/api-guide/serializers/#field-level-validation)

您可以通过向子类中添加`.validate_`方法来指定自定义字段级验证`Serializer`。这些类似于`.clean_`在Django表单上的方法。

这些方法采用单个参数，该参数是需要验证的字段值。

您的`validate_`方法应返回经过验证的值或引发`serializers.ValidationError`。例如：

```python
from rest_framework import serializers

class BlogPostSerializer(serializers.Serializer):
    title = serializers.CharField(max_length=100)
    content = serializers.CharField()

    def validate_title(self, value):
        """
        Check that the blog post is about Django.
        """
        if 'django' not in value.lower():
            raise serializers.ValidationError("Blog post is not about Django")
        return value
```

------

**注意：**如果您的`<field_name>`是在序列化程序上用参数`required=False`声明的，那么如果不包含该字段，则不会执行此验证步骤。

------

#### [Object-level验证](https://www.django-rest-framework.org/api-guide/serializers/#object-level-validation)

若要执行任何其他需要访问多个字段的验证，请将名为`.validate（）`的方法添加到序列化程序`Serializer`子类中。此方法只接受一个参数，它是字段值的字典。它应该在必要时引发`serializers.ValidationError`，或者只返回已验证的值。例如：

```python
from rest_framework import serializers

class EventSerializer(serializers.Serializer):
    description = serializers.CharField(max_length=100)
    start = serializers.DateTimeField()
    finish = serializers.DateTimeField()

    def validate(self, data):
        """
        Check that start is before finish.
        """
        if data['start'] > data['finish']:
            raise serializers.ValidationError("finish must occur after start")
        return data
```

#### [验证器](https://www.django-rest-framework.org/api-guide/serializers/#validators)

序列化程序上的各个字段可以包含验证器，方法是在字段实例上声明它们，例如：

```python
def multiple_of_ten(value):
    if value % 10 != 0:
        raise serializers.ValidationError('Not a multiple of ten')

class GameRecord(serializers.Serializer):
    score = IntegerField(validators=[multiple_of_ten])
    ...
```

序列化程序类还可以包括可重复使用的验证器，这些验证器将应用于完整的字段数据集。通过在内部`Meta`类上声明它们来包括这些验证器，如下所示：

```python
class EventSerializer(serializers.Serializer):
    name = serializers.CharField()
    room_number = serializers.IntegerField(choices=[101, 102, 103, 201])
    date = serializers.DateField()

    class Meta:
        # Each room only has one event per day.
        validators = UniqueTogetherValidator(
            queryset=Event.objects.all(),
            fields=['room_number', 'date']
        )
```

有关更多信息，请参见[验证程序文档](https://www.django-rest-framework.org/api-guide/validators/)。

## [访问初始数据和实例](https://www.django-rest-framework.org/api-guide/serializers/#accessing-the-initial-data-and-instance)

将初始对象或查询集传递给序列化程序实例时，该对象将变为可使用`.instance`。如果没有传递初始对象，则`.instance`属性将为`None`。

将数据传递给序列化程序实例时，未修改的数据将以形式提供`.initial_data`。如果未传递data关键字参数，则该`.initial_data`属性将不存在。

## [部分更新](https://www.django-rest-framework.org/api-guide/serializers/#partial-updates)

默认情况下，必须为所有必填字段传递序列化器值，否则序列化器会引发验证错误。您可以使用`partial`参数来允许部分更新。

```python
# Update `comment` with partial data
serializer = CommentSerializer(comment, data={'content': 'foo bar'}, partial=True)
```

## [处理嵌套对象](https://www.django-rest-framework.org/api-guide/serializers/#dealing-with-nested-objects)

前面的示例非常适合处理仅具有简单数据类型的对象，但是有时我们还需要能够表示更复杂的对象，其中对象的某些属性可能不是简单数据类型，例如字符串，日期或整数。

序列化程序`Serializer`类本身是一种字段`Field`类型，可用于表示一个对象类型嵌套在另一个对象类型中的关系。

```python
class UserSerializer(serializers.Serializer):
    email = serializers.EmailField()
    username = serializers.CharField(max_length=100)

class CommentSerializer(serializers.Serializer):
    user = UserSerializer()
    content = serializers.CharField(max_length=200)
    created = serializers.DateTimeField()
```

如果嵌套表示形式可以选择接受该`None`值，则应将`required=False`标志传递给嵌套序列化器。

```python
class CommentSerializer(serializers.Serializer):
    user = UserSerializer(required=False)  # May be an anonymous user.
    content = serializers.CharField(max_length=200)
    created = serializers.DateTimeField()
```

同样，如果嵌套表示形式应为项目列表，则应将`many=True`标志传递给嵌套序列化。

```python
class CommentSerializer(serializers.Serializer):
    user = UserSerializer(required=False)
    edits = EditItemSerializer(many=True)  # A nested list of 'edit' items.
    content = serializers.CharField(max_length=200)
    created = serializers.DateTimeField()
```

## [可写的嵌套表示](https://www.django-rest-framework.org/api-guide/serializers/#writable-nested-representations)

当处理支持反序列化数据的嵌套表示形式时，嵌套对象的任何错误都将嵌套在嵌套对象的字段名称下。

```python
serializer = CommentSerializer(data={'user': {'email': 'foobar', 'username': 'doe'}, 'content': 'baz'})
serializer.is_valid()
# False
serializer.errors
# {'user': {'email': ['Enter a valid e-mail address.']}, 'created': ['This field is required.']}
```

同样，该`.validated_data`属性将包括嵌套的数据结构。

#### [为嵌套表示编写`.create（）`方法](https://www.django-rest-framework.org/api-guide/serializers/#writing-create-methods-for-nested-representations)

如果您支持可写的嵌套表示形式，则需要编写`.create()`或`.update()`处理保存多个对象的方法。

以下示例演示了如何使用嵌套的配置文件对象创建用户。

```python
class UserSerializer(serializers.ModelSerializer):
    profile = ProfileSerializer()

    class Meta:
        model = User
        fields = ['username', 'email', 'profile']

    def create(self, validated_data):
        profile_data = validated_data.pop('profile')
        user = User.objects.create(**validated_data)
        Profile.objects.create(user=user, **profile_data)
        return user
```

#### [为嵌套表示编写`.update（）`方法](https://www.django-rest-framework.org/api-guide/serializers/#writing-update-methods-for-nested-representations)

对于更新，您需要仔细考虑如何处理关系更新。例如，如果该关系的数据为`None`，或未提供，应发生以下哪项？

- `NULL`在数据库中将关系设置为。
- 删除关联的实例。
- 忽略数据，并保持实例不变。
- 引发验证错误。

这是`.update()`我们上一`UserSerializer`类的方法的示例。

```python
    def update(self, instance, validated_data):
        profile_data = validated_data.pop('profile')
        # Unless the application properly enforces that this field is
        # always set, the follow could raise a `DoesNotExist`, which
        # would need to be handled.
        profile = instance.profile

        instance.username = validated_data.get('username', instance.username)
        instance.email = validated_data.get('email', instance.email)
        instance.save()

        profile.is_premium_member = profile_data.get(
            'is_premium_member',
            profile.is_premium_member
        )
        profile.has_support_contract = profile_data.get(
            'has_support_contract',
            profile.has_support_contract
         )
        profile.save()

        return instance
```

由于嵌套创建和更新的行为可能是模棱两可的，并且可能需要相关模型之间的复杂依赖性，因此REST框架3要求您始终明确地编写这些方法。默认`ModelSerializer` `.create()`和`.update()`方法不包括对可写嵌套表示的支持。

但是，有第三方软件包，例如[DRF Writable Nested](https://www.django-rest-framework.org/api-guide/serializers/#drf-writable-nested)，它们支持自动可写嵌套表示。

#### [在模型管理器类中处理保存相关实例](https://www.django-rest-framework.org/api-guide/serializers/#handling-saving-related-instances-in-model-manager-classes)

在序列化程序中保存多个相关实例的替代方法是编写自定义模型管理器类，以处理创建正确的实例。

例如，假设我们要确保`User`实例和`Profile`实例始终一起成对创建。我们可能会编写一个类似于以下内容的自定义管理器类：

```python
class UserManager(models.Manager):
    ...

    def create(self, username, email, is_premium_member=False, has_support_contract=False):
        user = User(username=username, email=email)
        user.save()
        profile = Profile(
            user=user,
            is_premium_member=is_premium_member,
            has_support_contract=has_support_contract
        )
        profile.save()
        return user
```

现在，该管理器类更好地封装了始终在同时创建用户实例和概要文件实例的情况。我们`.create()`在串行类的方法，现在可以重新编写，使用新的管理器方法。

```python
def create(self, validated_data):
    return User.objects.create(
        username=validated_data['username'],
        email=validated_data['email']
        is_premium_member=validated_data['profile']['is_premium_member']
        has_support_contract=validated_data['profile']['has_support_contract']
    )
```

有关此方法的更多详细信息，请参阅有关[模型管理器](https://docs.djangoproject.com/en/stable/topics/db/managers/)的Django文档，以及[有关使用模型和管理器类的博客](https://www.dabapps.com/blog/django-models-and-encapsulation/)。

## [处理多个对象](https://www.django-rest-framework.org/api-guide/serializers/#dealing-with-multiple-objects)

该`Serializer`班还可以处理序列化或反序列化对象的列表。

#### [序列化多个对象](https://www.django-rest-framework.org/api-guide/serializers/#serializing-multiple-objects)

要序列化查询集或对象列表而不是单个对象实例，应`many=True`在实例化序列化程序时传递该标志。然后，您可以传递查询集或要序列化的对象列表。

```python
queryset = Book.objects.all()
serializer = BookSerializer(queryset, many=True)
serializer.data
# [
#     {'id': 0, 'title': 'The electric kool-aid acid test', 'author': 'Tom Wolfe'},
#     {'id': 1, 'title': 'If this is a man', 'author': 'Primo Levi'},
#     {'id': 2, 'title': 'The wind-up bird chronicle', 'author': 'Haruki Murakami'}
# ]
```

#### [反序列化多个对象](https://www.django-rest-framework.org/api-guide/serializers/#deserializing-multiple-objects)

反序列化多个对象的默认行为是支持多个对象创建，但不支持多个对象更新。有关如何支持或自定义这两种情况的更多信息，请参见下面的[ListSerializer](https://www.django-rest-framework.org/api-guide/serializers/#listserializer)文档。

## [包括额外的上下文](https://www.django-rest-framework.org/api-guide/serializers/#including-extra-context)

在某些情况下，除了要序列化的对象外，还需要向序列化器提供额外的上下文。一种常见的情况是，如果您使用的是包含超链接关系的序列化程序，则要求序列化程序有权访问当前请求，以便它可以正确生成完全合格的URL。

您可以`context`在实例化序列化程序时通过传递参数来提供任意其他上下文。例如：

```python
serializer = AccountSerializer(account, context={'request': request})
serializer.data
# {'id': 6, 'owner': 'denvercoder9', 'created': datetime.datetime(2013, 2, 12, 09, 44, 56, 678870), 'details': 'http://example.com/accounts/6/details'}
```

`.to_representation()`通过访问`self.context`属性，可以在任何序列化程序字段逻辑（例如自定义方法）中使用上下文字典。

------

# [ModelSerializer](https://www.django-rest-framework.org/api-guide/serializers/#modelserializer)

通常，您会需要与Django模型定义紧密映射的序列化程序类。

本`ModelSerializer`类提供了一个快捷方式，可以让你自动创建一个`Serializer`类的字段对应示范场。

**`ModelSerializer`与常规的`Serializer`类一样，不同之处在于**：

- 它将根据模型自动为您生成一组字段。
- 它将自动为序列化器生成验证器，例如unique_together验证器。
- 它包括简单的默认实现`.create()`和`.update()`。

声明`ModelSerializer`如下所示：

```python
class AccountSerializer(serializers.ModelSerializer):
    class Meta:
        model = Account
        fields = ['id', 'account_name', 'users', 'created']
```

默认情况下，该类上的所有模型字段都将映射到相应的序列化器字段。

任何关系（例如模型上的外键）都将映射到`PrimaryKeyRelatedField`。默认情况下不包括反向关系，除非按照[序列化器关系](https://www.django-rest-framework.org/api-guide/relations/)文档中的指定明确包含反向关系。

#### [检查一个 `ModelSerializer`](https://www.django-rest-framework.org/api-guide/serializers/#inspecting-a-modelserializer)

序列化程序类会生成有用的详细表示形式字符串，使您可以全面检查其字段的状态。这`ModelSerializers`在您要确定要为您自动创建哪些字段和验.证器的地方工作时特别有用。

为此，请使用打开Django Shell，`python manage.py shell`然后导入序列化程序类，实例化它，然后打印对象表示形式…

```python
>>> from myapp.serializers import AccountSerializer
>>> serializer = AccountSerializer()
>>> print(repr(serializer))
AccountSerializer():
    id = IntegerField(label='ID', read_only=True)
    name = CharField(allow_blank=True, max_length=100, required=False)
    owner = PrimaryKeyRelatedField(queryset=User.objects.all())
```

## [指定要包括的字段](https://www.django-rest-framework.org/api-guide/serializers/#specifying-which-fields-to-include)

如果只希望在模型序列化器中使用默认字段的子集，则可以使用`fields`或`exclude`选项，就像使用一样`ModelForm`。强烈建议您使用`fields`属性显式设置应序列化的所有字段。这将减少在模型更改时导致意外暴露数据的可能性。

例如：

```python
class AccountSerializer(serializers.ModelSerializer):
    class Meta:
        model = Account
        fields = ['id', 'account_name', 'users', 'created']
```

您也可以将`fields`属性设置为特殊值，`'__all__'`以指示应使用模型中的所有字段。

例如：

```python
class AccountSerializer(serializers.ModelSerializer):
    class Meta:
        model = Account
        fields = '__all__'
```

您可以将`exclude`属性设置为要从序列化器中排除的字段列表。

例如：

```python
class AccountSerializer(serializers.ModelSerializer):
    class Meta:
        model = Account
        exclude = ['users']
```

在上面的例子中，如果`Account`模型具有3个字段`account_name`，`users`和`created`，这将导致在字段`account_name`和`created`被序列化。

`fields`和`exclude`属性中的名称通常会映射到模型类上的模型字段。

另外，`fields`选项中的名称可以映射到属性或方法，这些属性或方法不包含模型类上存在的参数。

从3.3.0版开始，**必须**提供属性`fields`或`exclude`之一。

## [指定嵌套序列化](https://www.django-rest-framework.org/api-guide/serializers/#specifying-nested-serialization)

默认`ModelSerializer`使用关系的主键，但是您也可以使用以下`depth`选项轻松生成嵌套表示：

```python
class AccountSerializer(serializers.ModelSerializer):
    class Meta:
        model = Account
        fields = ['id', 'account_name', 'users', 'created']
        depth = 1
```

该`depth`选项应设置为一个整数值，该值指示在还原为平面表示形式之前应遍历的关系的深度。

如果要自定义完成序列化的方式，则需要自己定义字段。

## [显式指定字段](https://www.django-rest-framework.org/api-guide/serializers/#specifying-fields-explicitly)

您可以`ModelSerializer`像在类上一样，通过在类上声明字段来向上添加额外的字段或覆盖默认字段`Serializer`。

```python
class AccountSerializer(serializers.ModelSerializer):
    url = serializers.CharField(source='get_absolute_url', read_only=True)
    groups = serializers.PrimaryKeyRelatedField(many=True)

    class Meta:
        model = Account
```

多余的字段可以对应于模型中的任何属性或可调用的字段。

## [指定只读字段](https://www.django-rest-framework.org/api-guide/serializers/#specifying-read-only-fields)

您可能希望将多个字段指定为只读。除了使用`read_only=True`属性显式添加每个字段外，您还可以使用快捷方式Meta选项`read_only_fields`。

此选项应该是字段名称的列表或元组，并且声明如下：

```python
class AccountSerializer(serializers.ModelSerializer):
    class Meta:
        model = Account
        fields = ['id', 'account_name', 'users', 'created']
        read_only_fields = ['account_name']
```

默认情况下，已`editable=False`设置的模型字段和`AutoField`字段将设置为只读，并且不需要将其添加到该`read_only_fields`选项中。

------

**注意**：在特殊情况下，只读字段是`unique_together`模型级别约束的一部分。在这种情况下，序列化程序类需要该字段以验证约束，但用户也不能编辑该字段。

解决此问题的正确方法是在序列化程序上显式指定字段，同时提供`read_only=True`和`default=…`关键字参数。

这方面的一个示例`User`是`unique_together`与当前身份验证的只读关系，该关系与另一个标识符相关。在这种情况下，您将这样声明用户字段：

```python
user = serializers.PrimaryKeyRelatedField(read_only=True, default=serializers.CurrentUserDefault())
```

请查看[验证程序文档，](https://www.django-rest-framework.org/api-guide/validators/)以获取有关[UniqueTogetherValidator](https://www.django-rest-framework.org/api-guide/validators/#uniquetogethervalidator)和[CurrentUserDefault](https://www.django-rest-framework.org/api-guide/validators/#currentuserdefault)类的详细信息。

------

## [附加关键字参数](https://www.django-rest-framework.org/api-guide/serializers/#additional-keyword-arguments)

还有一个快捷方式，允许您使用该`extra_kwargs`选项在字段上指定任意其他关键字参数。与`read_only_fields`的情况一样，这意味着您无需在序列化程序上显式声明该字段。

此选项是一个字典，将字段名称映射到关键字参数字典。例如：

```python
class CreateUserSerializer(serializers.ModelSerializer):
    class Meta:
        model = User
        fields = ['email', 'username', 'password']
        extra_kwargs = {'password': {'write_only': True}}

    def create(self, validated_data):
        user = User(
            email=validated_data['email'],
            username=validated_data['username']
        )
        user.set_password(validated_data['password'])
        user.save()
        return user
```

请记住，如果已在序列化程序类上显式声明了该字段，则该`extra_kwargs`选项将被忽略。

## [关系字段](https://www.django-rest-framework.org/api-guide/serializers/#relational-fields)

序列化模型实例时，可以选择多种方式来表示关系。默认表示形式`ModelSerializer`是使用相关实例的主键。

其他表示形式包括使用超链接进行序列化，序列化完整的嵌套表示形式或使用自定义表示形式进行序列化。

有关完整的详细信息，请参见[序列化程序关系](https://www.django-rest-framework.org/api-guide/relations/)文档。

## [自定义字段映射](https://www.django-rest-framework.org/api-guide/serializers/#customizing-field-mappings)

`ModelSerializer`类还公开了一个API，您可以重写该API，以更改在实例化序列化程序时自动确定序列化程序字段的方式。

通常，如果`ModelSerializer`在默认情况下不生成所需的字段，则应将它们显式添加到类中，或者直接使用常规序列化程序`Serializer`类。但是，在某些情况下，您可能希望创建一个新基类，该基类定义如何为任何给定模型创建序列化程序字段。

### [`.serializer_field_mapping`](https://www.django-rest-framework.org/api-guide/serializers/#serializer_field_mapping)

Django模型类到REST框架序列化器类的映射。您可以重写此映射，以更改应用于每个模型类的默认序列化器类。

### [`.serializer_related_field`](https://www.django-rest-framework.org/api-guide/serializers/#serializer_related_field)

此属性应该是序列化程序字段类，默认情况下用于关系字段。

对于`ModelSerializer`此默认值为`PrimaryKeyRelatedField`。

对于`HyperlinkedModelSerializer`此默认值为`serializers.HyperlinkedRelatedField`。

### [`serializer_url_field`](https://www.django-rest-framework.org/api-guide/serializers/#serializer_url_field)

应该用于`url`序列化程序上任何字段的序列化程序字段类。

默认为 `serializers.HyperlinkedIdentityField`

### [`serializer_choice_field`](https://www.django-rest-framework.org/api-guide/serializers/#serializer_choice_field)

应该用于序列化程序上任何选择字段的序列化程序字段类。

默认为 `serializers.ChoiceField`

### [field_class和field_kwargs API](https://www.django-rest-framework.org/api-guide/serializers/#the-field_class-and-field_kwargs-api)

调用以下方法来确定应该自动包含在序列化程序中的每个字段的类和关键字参数。这些方法中的每一个都应返回的两个元组`(field_class, field_kwargs)`。

### [`.build_standard_field(self, field_name, model_field)`](https://www.django-rest-framework.org/api-guide/serializers/#build_standard_fieldself-field_name-model_field)

调用以生成映射到标准模型字段的序列化器字段。

默认实现基于`serializer_field_mapping`属性返回一个序列化器类。

### [`.build_relational_field(self, field_name, relation_info)`](https://www.django-rest-framework.org/api-guide/serializers/#build_relational_fieldself-field_name-relation_info)

调用以生成映射到关系模型字段的序列化器字段。

默认实现基于`serializer_related_field`属性返回一个序列化器类。

该`relation_info`参数是一个名为元组，包含`model_field`，`related_model`，`to_many`和`has_through_model`属性。

### [`.build_nested_field(self, field_name, relation_info, nested_depth)`](https://www.django-rest-framework.org/api-guide/serializers/#build_nested_fieldself-field_name-relation_info-nested_depth)

设置选项后，调用此方法生成映射到关系模型字段的序列化器字段`depth`。

默认实现基于`ModelSerializer`或动态创建嵌套的序列化程序类`HyperlinkedModelSerializer`。

该`nested_depth`会的价值`depth`选择，减之一。

该`relation_info`参数是一个名为元组，包含`model_field`，`related_model`，`to_many`和`has_through_model`属性。

### [`.build_property_field(self, field_name, model_class)`](https://www.django-rest-framework.org/api-guide/serializers/#build_property_fieldself-field_name-model_class)

调用以生成一个序列化器字段，该字段映射到模型类上的属性或零参数方法。

默认实现返回一个`ReadOnlyField`类。

### [`.build_url_field(self, field_name, model_class)`](https://www.django-rest-framework.org/api-guide/serializers/#build_url_fieldself-field_name-model_class)

调用以为序列化器自己的`url`字段生成一个序列化器字段。默认实现返回一个`HyperlinkedIdentityField`类。

### [`.build_unknown_field(self, field_name, model_class)`](https://www.django-rest-framework.org/api-guide/serializers/#build_unknown_fieldself-field_name-model_class)

当字段名称未映射到任何模型字段或模型属性时调用。尽管子类可以自定义此行为，但默认实现会引发错误。

------

# [超链接模型序列化器](https://www.django-rest-framework.org/api-guide/serializers/#hyperlinkedmodelserializer)

的`HyperlinkedModelSerializer`类是类似于`ModelSerializer`不同之处在于它使用的超链接来表示的关系，而不是主键类。

默认情况下，序列化程序将包含一个`url`字段而不是主键字段。

url字段将使用`HyperlinkedIdentityField`序列化器字段表示，模型上的任何关系都将使用`HyperlinkedRelatedField`序列化器字段表示。

您可以通过将主键添加到`fields`选项中来显式包括主键，例如：

```python
class AccountSerializer(serializers.HyperlinkedModelSerializer):
    class Meta:
        model = Account
        fields = ['url', 'id', 'account_name', 'users', 'created']
```

## [绝对和相对URL](https://www.django-rest-framework.org/api-guide/serializers/#absolute-and-relative-urls)

实例化超链接`ModelSerializer`时，必须在序列化程序上下文中包含当前`request`，例如：

```python
serializer = AccountSerializer(queryset, context={'request': request})
```

这样做将确保超链接可以包含适当的主机名，以使生成的表示形式使用完全限定的URL，例如：

```python
http://api.example.com/accounts/1/
```

而不是相对URL，例如：

```python
/accounts/1/
```

如果*确实*要使用相对URL，则应显式传递`{'request': None}` 序列化程序上下文。

## [如何确定超链接视图](https://www.django-rest-framework.org/api-guide/serializers/#how-hyperlinked-views-are-determined)

需要一种确定应该使用哪些视图来超链接到模型实例的方法。

默认情况下，超链接应与匹配样式的视图名称相对应`'{model_name}-detail'`，并通过`pk`关键字参数查找实例。

您可以使用设置中的`view_name`和`lookup_field`选项之一或全部覆盖URL字段视图名称和查找字段`extra_kwargs`，如下所示：

```python
class AccountSerializer(serializers.HyperlinkedModelSerializer):
    class Meta:
        model = Account
        fields = ['account_url', 'account_name', 'users', 'created']
        extra_kwargs = {
            'url': {'view_name': 'accounts', 'lookup_field': 'account_name'},
            'users': {'lookup_field': 'username'}
        }
```

或者，您可以在串行器上显式设置字段。例如：

```python
class AccountSerializer(serializers.HyperlinkedModelSerializer):
    url = serializers.HyperlinkedIdentityField(
        view_name='accounts',
        lookup_field='slug'
    )
    users = serializers.HyperlinkedRelatedField(
        view_name='user-detail',
        lookup_field='username',
        many=True,
        read_only=True
    )

    class Meta:
        model = Account
        fields = ['url', 'account_name', 'users', 'created']
```

------

**提示**：正确地将超链接的表示形式和您的URL conf匹配在一起有时可能有点麻烦。打印`repr`一个的`HyperlinkedModelSerializer`实例来检查到底是哪视图名和查询领域的关系预计将映射过一个特别有用的方法。

------

## [更改URL字段名称](https://www.django-rest-framework.org/api-guide/serializers/#changing-the-url-field-name)

URL字段的名称默认为“ url”。您可以使用`URL_FIELD_NAME`设置在全局范围内覆盖此设置。

------

# [ListSerializer](https://www.django-rest-framework.org/api-guide/serializers/#listserializer)

本`ListSerializer`类提供了序列化和一次验证多个对象的行为。您*通常*不需要`ListSerializer`直接使用，而应该`many=True`在实例化序列化程序时简单地通过。

实例化并`many=True`传递序列化程序时，`ListSerializer`将创建一个实例。然后，序列化程序类成为父级的子级`ListSerializer`

以下参数也可以传递给传递的`ListSerializer`字段或序列化器`many=True`：

### [`allow_empty`](https://www.django-rest-framework.org/api-guide/serializers/#allow_empty)

默认情况下为`True`，但如果要禁止空列表作为有效输入，则可以将其设置为`False`。

### [自定义`ListSerializer`行为](https://www.django-rest-framework.org/api-guide/serializers/#customizing-listserializer-behavior)

这里*是*一些使用情况下，您可能希望定制的`ListSerializer`行为。例如：

- 您想要提供列表的特定验证，例如检查一个元素与列表中的另一个元素没有冲突。
- 您要自定义多个对象的创建或更新行为。

对于这些情况，可以`many=True`通过使用`list_serializer_class`序列化程序`Meta`类上的选项来修改传递时使用的类。

例如：

```python
class CustomListSerializer(serializers.ListSerializer):
    ...

class CustomSerializer(serializers.Serializer):
    ...
    class Meta:
        list_serializer_class = CustomListSerializer
```

#### [自定义多个创建](https://www.django-rest-framework.org/api-guide/serializers/#customizing-multiple-create)

多对象创建的默认实现是简单地为列表中的每个项调用`.create（）`。如果要自定义此行为，则需要在传递`many=True`时使用的`ListSerializer`类上自定义`.create（）`方法。

例如：

```python
class BookListSerializer(serializers.ListSerializer):
    def create(self, validated_data):
        books = [Book(**item) for item in validated_data]
        return Book.objects.bulk_create(books)

class BookSerializer(serializers.Serializer):
    ...
    class Meta:
        list_serializer_class = BookListSerializer
```

#### [自定义多个更新](https://www.django-rest-framework.org/api-guide/serializers/#customizing-multiple-update)

默认情况下，`ListSerializer`该类不支持多个更新。这是因为插入和删除应预期的行为是模棱两可的。

要支持多个更新，您需要明确地这样做。在编写多个更新代码时，请确保牢记以下几点：

- 您如何确定应该为数据列表中的每个项目更新哪个实例？
- 应该如何处理插入？它们是无效的还是创建新对象？
- 应如何处理清除？它们是否意味着对象删除或删除关系？应该默默地忽略它们还是无效？
- 订购应该如何处理？更改两个项目的位置是否意味着状态发生任何变化或被忽略？

您将需要向`id`实例序列化器添加一个显式字段。默认的隐式生成的`id`字段标记为`read_only`。这导致它在更新时被删除。一旦明确声明它，它将在列表序列化程序的`update`方法中可用。

这是一个示例，您可以选择如何实施多个更新：

```python
class BookListSerializer(serializers.ListSerializer):
    def update(self, instance, validated_data):
        # Maps for id->instance and id->data item.
        book_mapping = {book.id: book for book in instance}
        data_mapping = {item['id']: item for item in validated_data}

        # Perform creations and updates.
        ret = []
        for book_id, data in data_mapping.items():
            book = book_mapping.get(book_id, None)
            if book is None:
                ret.append(self.child.create(data))
            else:
                ret.append(self.child.update(book, data))

        # Perform deletions.
        for book_id, book in book_mapping.items():
            if book_id not in data_mapping:
                book.delete()

        return ret

class BookSerializer(serializers.Serializer):
    # We need to identify elements in the list using their primary key,
    # so use a writable field here, rather than the default which would be read-only.
    id = serializers.IntegerField()
    ...

    class Meta:
        list_serializer_class = BookListSerializer
```

第三方包可能与3.1版本一起提供对多个更新操作的一些自动支持，类似于REST框架2中的`allow-add-remove`行为。

#### [自定义ListSerializer初始化](https://www.django-rest-framework.org/api-guide/serializers/#customizing-listserializer-initialization)

当`many=True`实例化带有的序列化器时，我们需要确定`.__init__()`子`Serializer`类和父`ListSerializer`类都应将哪些参数和关键字参数传递给该方法。

默认实现是将所有参数传递给两个类，除了`validators`和以及任何自定义关键字参数（假定这两个参数都旨在用于子序列化器类）之外。

有时，您可能需要明确指定在`many=True`传递时应如何实例化子类和父类。您可以通过使用`many_init`class方法来实现。

```python
    @classmethod
    def many_init(cls, *args, **kwargs):
        # Instantiate the child serializer.
        kwargs['child'] = cls()
        # Instantiate the parent list serializer.
        return CustomListSerializer(*args, **kwargs)
```

------

# [BaseSerializer](https://www.django-rest-framework.org/api-guide/serializers/#baseserializer)

`BaseSerializer` 可用于轻松支持替代序列化和反序列化样式的类。

此类实现与该类相同的基本API `Serializer`：

- `.data` -返回传出的原始表示形式。
- `.is_valid()` -反序列化并验证传入的数据。
- `.validated_data` -返回经过验证的传入数据。
- `.errors` -返回验证期间的所有错误。
- `.save()` -将验证后的数据持久化为对象实例。

可以覆盖四种方法，具体取决于您希望序列化程序类支持什么功能：

- `.to_representation()` -覆盖它以支持序列化，以进行读取操作。
- `.to_internal_value()` -重写此属性以支持反序列化，以进行写操作。
- `.create()`和`.update()`-覆盖一个或两个的这些支持节能实例。

因为此类提供与该类相同的接口，所以`Serializer`您可以将其与现有的基于通用类的视图一起使用，就像使用常规`Serializer`或一样`ModelSerializer`。

您这样做时会注意到的唯一区别是，这些`BaseSerializer`类不会在可浏览的API中生成HTML表单。这是因为它们返回的数据不包括所有字段信息，该信息将允许将每个字段呈现为合适的HTML输入。

##### [只读`BaseSerializer`类](https://www.django-rest-framework.org/api-guide/serializers/#read-only-baseserializer-classes)

要使用`BaseSerializer`该类实现只读的序列化程序，我们只需要重写该`.to_representation()`方法即可。让我们来看一个使用简单Django模型的示例：

```python
class HighScore(models.Model):
    created = models.DateTimeField(auto_now_add=True)
    player_name = models.CharField(max_length=10)
    score = models.IntegerField()
```

创建一个只读的序列化器将`HighScore`实例转换为原始数据类型很简单。

```python
class HighScoreSerializer(serializers.BaseSerializer):
    def to_representation(self, instance):
        return {
            'score': instance.score,
            'player_name': instance.player_name
        }
```

现在，我们可以使用此类来序列化单个`HighScore`实例：

```python
@api_view(['GET'])
def high_score(request, pk):
    instance = HighScore.objects.get(pk=pk)
    serializer = HighScoreSerializer(instance)
    return Response(serializer.data)
```

或使用它来序列化多个实例：

```python
@api_view(['GET'])
def all_high_scores(request):
    queryset = HighScore.objects.order_by('-score')
    serializer = HighScoreSerializer(queryset, many=True)
    return Response(serializer.data)
```

##### [读写`BaseSerializer`类](https://www.django-rest-framework.org/api-guide/serializers/#read-write-baseserializer-classes)

要创建读写序列化器，我们首先需要实现一个`.to_internal_value()`方法。此方法返回将用于构造对象实例的验证值，`serializers.ValidationError`如果提供的数据格式不正确，则可能会引发。

一旦你已经实现`.to_internal_value()`，基本验证API将可在串行器，你将能够使用`.is_valid()`，`.validated_data`和`.errors`。

如果您还想要支持，则还`.save()`需要实现`.create()`和`.update()`方法中的一个或两个。

这是我们之前的完整示例，`HighScoreSerializer`已更新为支持读取和写入操作。

```python
class HighScoreSerializer(serializers.BaseSerializer):
    def to_internal_value(self, data):
        score = data.get('score')
        player_name = data.get('player_name')

        # Perform the data validation.
        if not score:
            raise serializers.ValidationError({
                'score': 'This field is required.'
            })
        if not player_name:
            raise serializers.ValidationError({
                'player_name': 'This field is required.'
            })
        if len(player_name) > 10:
            raise serializers.ValidationError({
                'player_name': 'May not be more than 10 characters.'
            })

        # Return the validated values. This will be available as
        # the `.validated_data` property.
        return {
            'score': int(score),
            'player_name': player_name
        }

    def to_representation(self, instance):
        return {
            'score': instance.score,
            'player_name': instance.player_name
        }

    def create(self, validated_data):
        return HighScore.objects.create(**validated_data)
```

#### [创建新的基类](https://www.django-rest-framework.org/api-guide/serializers/#creating-new-base-classes)

的`BaseSerializer`，如果你想实现新的通用序列化类来处理特定的序列化的风格，或者使用可替换存储后端集成类也是有用的。

下列类是通用序列化器的示例，该序列化器可以处理将任意对象强制转换为原始表示形式。

```python
class ObjectSerializer(serializers.BaseSerializer):
    """
    A read-only serializer that coerces arbitrary complex objects
    into primitive representations.
    """
    def to_representation(self, instance):
        output = {}
        for attribute_name in dir(instance):
            attribute = getattr(instance, attribute_name)
            if attribute_name.startswith('_'):
                # Ignore private attributes.
                pass
            elif hasattr(attribute, '__call__'):
                # Ignore methods and other callables.
                pass
            elif isinstance(attribute, (str, int, bool, float, type(None))):
                # Primitive types can be passed through unmodified.
                output[attribute_name] = attribute
            elif isinstance(attribute, list):
                # Recursively deal with items in lists.
                output[attribute_name] = [
                    self.to_representation(item) for item in attribute
                ]
            elif isinstance(attribute, dict):
                # Recursively deal with items in dictionaries.
                output[attribute_name] = {
                    str(key): self.to_representation(value)
                    for key, value in attribute.items()
                }
            else:
                # Force anything else to its string representation.
                output[attribute_name] = str(attribute)
        return output
```

------

# [先进的序列化器用法](https://www.django-rest-framework.org/api-guide/serializers/#advanced-serializer-usage)

## [重写序列化和反序列化行为](https://www.django-rest-framework.org/api-guide/serializers/#overriding-serialization-and-deserialization-behavior)

如果需要更改序列化程序类的序列化或反序列化行为，则可以通过重写`.to_representation()`或`.to_internal_value()`方法来实现。

这可能有用的一些原因包括...

- 为新的序列化器基类添加新行为。
- 稍微修改现有类的行为。
- 提高返回大量数据的频繁访问的API端点的序列化性能。

这些方法的签名如下：

#### [`.to_representation(self, instance)`](https://www.django-rest-framework.org/api-guide/serializers/#to_representationself-instance)

接受需要序列化的对象实例，并应返回原始表示形式。通常，这意味着返回内置Python数据类型的结构。可以处理的确切类型取决于您为API配置的渲染类。

可以重写以修改表示样式。例如：

```python
def to_representation(self, instance):
    """Convert `username` to lowercase."""
    ret = super().to_representation(instance)
    ret['username'] = ret['username'].lower()
    return ret
```

#### [`.to_internal_value(self, data)`](https://www.django-rest-framework.org/api-guide/serializers/#to_internal_valueself-data)

将未经验证的传入数据作为输入，并应返回将以形式提供的经过验证的数据`serializer.validated_data`。如果在序列化程序类上被调用，则返回值还将传递给`.create()`or `.update()`方法`.save()`。

如果任何验证失败，则该方法应引发一个`serializers.ValidationError(errors)`。该`errors`参数应该是一个字典映射字段名称（或`settings.NON_FIELD_ERRORS_KEY`）到错误消息的列表。如果您不需要更改反序列化行为，而想要提供对象级验证，则建议您改写该[`.validate()`](https://www.django-rest-framework.org/api-guide/serializers/#object-level-validation)方法。

`data`传递给此方法的参数通常是的值`request.data`，因此它提供的数据类型将取决于您为API配置的解析器类。

## [序列化器继承](https://www.django-rest-framework.org/api-guide/serializers/#serializer-inheritance)

与Django表单类似，您可以通过继承扩展和重用序列化器。这使您可以在父类上声明一组通用的字段或方法，然后可以在许多序列化程序中使用它们。例如，

```python
class MyBaseSerializer(Serializer):
    my_field = serializers.CharField()

    def validate_my_field(self, value):
        ...

class MySerializer(MyBaseSerializer):
    ...
```

像Django的`Model`和`ModelForm`类一样，`Meta`序列化程序上的内部类不会隐式继承其父级的内部`Meta`类。如果要让`Meta`该类从父类继承，则必须明确地这样做。例如：

```python
class AccountSerializer(MyBaseSerializer):
    class Meta(MyBaseSerializer.Meta):
        model = Account
```

通常，我们建议*不要*在内部Meta类上使用继承，而应显式声明所有选项。

此外，以下警告适用于序列化程序继承：

- 正常的Python名称解析规则适用。如果您有多个声明`Meta`内部类的基类，则仅使用第一个基类。这意味着孩子的`Meta`（如果存在），否则`Meta`是第一位父母的孩子，等等。

- `Field`通过将名称设置为子类，可以声明性地删除从父类继承的继承`None`。

  ```python
  class MyBaseSerializer(ModelSerializer):
      my_field = serializers.CharField()
  
  class MySerializer(MyBaseSerializer):
      my_field = None
  ```

  但是，您只能使用此技术来退出由父类声明性定义的字段；它不会阻止`ModelSerializer`生成默认字段。要退出默认字段，请参见[指定要包括的字段](https://www.django-rest-framework.org/api-guide/serializers/#specifying-which-fields-to-include)。

## [动态修改字段](https://www.django-rest-framework.org/api-guide/serializers/#dynamically-modifying-fields)

初始化序列化程序后，可以使用`.fields`属性访问序列化程序上设置的字段的字典。访问和修改此属性使您可以动态修改序列化程序。

`fields`直接修改参数使您可以做一些有趣的事情，例如在运行时更改序列化程序字段上的参数，而不是在声明序列化程序时。

### [例](https://www.django-rest-framework.org/api-guide/serializers/#example)

例如，如果您希望能够在初始化时设置序列化程序应使用的字段，则可以创建一个序列化程序类，如下所示：

```python
class DynamicFieldsModelSerializer(serializers.ModelSerializer):
    """
    A ModelSerializer that takes an additional `fields` argument that
    controls which fields should be displayed.
    """

    def __init__(self, *args, **kwargs):
        # Don't pass the 'fields' arg up to the superclass
        fields = kwargs.pop('fields', None)

        # Instantiate the superclass normally
        super(DynamicFieldsModelSerializer, self).__init__(*args, **kwargs)

        if fields is not None:
            # Drop any fields that are not specified in the `fields` argument.
            allowed = set(fields)
            existing = set(self.fields)
            for field_name in existing - allowed:
                self.fields.pop(field_name)
```

然后，您可以执行以下操作：

```python
>>> class UserSerializer(DynamicFieldsModelSerializer):
>>>     class Meta:
>>>         model = User
>>>         fields = ['id', 'username', 'email']
>>>
>>> print(UserSerializer(user))
{'id': 2, 'username': 'jonwatts', 'email': 'jon@example.com'}
>>>
>>> print(UserSerializer(user, fields=('id', 'email')))
{'id': 2, 'email': 'jon@example.com'}
```

## [自定义默认字段](https://www.django-rest-framework.org/api-guide/serializers/#customizing-the-default-fields)

REST框架2提供了一个API，允许开发人员覆盖`ModelSerializer`类如何自动生成默认字段集的方式。

该API包括`.get_field()`，`.get_pk_field()`和其他方法。

由于串行器已经从3.0进行了重新设计，因此该API不再存在。您仍然可以修改创建的字段，但是需要参考源代码，并且要注意，如果所做的更改是针对API的私有位的，则它们可能会发生变化。

------

# [第三方软件包](https://www.django-rest-framework.org/api-guide/serializers/#third-party-packages)

以下第三方软件包也可用。

## [Django REST marshmallow](https://www.django-rest-framework.org/api-guide/serializers/#django-rest-marshmallow)

`django rest marshmallow`包使用`python marshmallow`库为序列化程序提供了另一种实现。它公开了与REST框架序列化程序相同的API，并且可以在某些用例中用作`drop-in`替换。

## [Serpy](https://www.django-rest-framework.org/api-guide/serializers/#serpy)

该[serpy](https://github.com/clarkduvall/serpy)包是是为速度而序列化的另一种实现。[Serpy](https://github.com/clarkduvall/serpy)将复杂的数据类型序列化为简单的本机类型。可以将本机类型轻松转换为JSON或所需的任何其他格式。

## [MongoengineModelSerializer](https://www.django-rest-framework.org/api-guide/serializers/#mongoenginemodelserializer)

`django rest framework mongoengine`包提供了一个`MongoEngineModelSerializer`序列化器类，该类支持使用`MongoDB`作为`django rest framework`的存储层。

## [GeoFeatureModelSerializer](https://www.django-rest-framework.org/api-guide/serializers/#geofeaturemodelserializer)

`django rest framework gis`包提供了一个`GeoFeatureModelSerialize`r序列化器类，该类支持`GeoJSON`的读写操作。

## [HStoreSerializer](https://www.django-rest-framework.org/api-guide/serializers/#hstoreserializer)

`django rest framework hstore`包提供了一个`HStoreSerializer`来支持`django hstore DictionaryField model`字段及其模式特性。

## [Dynamic REST](https://www.django-rest-framework.org/api-guide/serializers/#dynamic-rest)

`dynamic-rest`包扩展了`ModelSerializer`和`ModelViewSet`接口，添加了API查询参数，用于筛选、排序和包含/排除序列化程序定义的所有字段和关系。

## [Dynamic Fields Mixin](https://www.django-rest-framework.org/api-guide/serializers/#dynamic-fields-mixin)

 [drf-dynamic-fields](https://github.com/dbrgn/drf-dynamic-fields)包提供一个混合动态地限制每个串行化器中的字段由一个URL参数指定的子集。

## [DRF FlexFields](https://www.django-rest-framework.org/api-guide/serializers/#drf-flexfields)

该[drf-flex-fields](https://github.com/rsinger86/drf-flex-fields)包扩展`ModelSerializer`和`ModelViewSet`以动态设置字段和扩大原始字段嵌套模型，无论是从URL参数和您的序列化器类定义提供了常用的功能。

## [Serializer Extensions](https://www.django-rest-framework.org/api-guide/serializers/#serializer-extensions)

在 [django-rest-framework-serializer-extensions](https://github.com/evenicoulddoit/django-rest-framework-serializer-extensions)包提供的工具集，干涸的序列化，通过允许在每个视图/请求的基础定义的字段。可以将字段列入白名单，列入黑名单，并且可以选择扩展子序列化程序。

## [HTML JSON Forms](https://www.django-rest-framework.org/api-guide/serializers/#html-json-forms)

的[html-json-forms](https://github.com/wq/html-json-forms) 包提供了用于处理的算法并串行``每（不活动）提交[HTML表格JSON规范](https://www.w3.org/TR/html-json-forms/)。序列化程序有助于处理HTML中任意嵌套的JSON结构。例如，``将被解释为`{"items": [{"id": "5"}]}`。

## [DRF-Base64](https://www.django-rest-framework.org/api-guide/serializers/#drf-base64)

[DRF-Base64](https://bitbucket.org/levit_scs/drf_base64)提供了一组字段和模型序列化程序，用于处理以base64编码的文件的上载。

## [QueryFields](https://www.django-rest-framework.org/api-guide/serializers/#queryfields)

[djangorestframework-queryfields](https://djangorestframework-queryfields.readthedocs.io/)允许API客户端指定通过包含/排除查询参数在响应中发送哪些字段。

## [DRF Writable Nested](https://www.django-rest-framework.org/api-guide/serializers/#drf-writable-nested)

的[drf-writable-nested](https://github.com/beda-software/drf-writable-nested) 包提供可写的嵌套模型序列化器，它允许创建具有嵌套相关数据/更新的模型。