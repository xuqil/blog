# 正则表达式匹配例子

### 特殊文件配置匹配

匹配文件中`[特定字符串开头] [类型] [名称] [{值}]`

如从如下配置文件中匹配`ltm node 名称 {空值}`和`ltm node 名称  {有换行的值}`

```
ltm node /Common/test4 {
    address 192.168.56.22
}
ltm node /Common/test5 { }
ltm pool /Common/test1 { }
ltm pool /Common/mypool {
    description 测试pool
    load-balancing-mode ratio-member
    members {
        /Common/test:80 {
            address 192.168.56.20
            description 测试number
            priority-group 1
            rate-limit 1
            ratio 3
        }
        /Common/test22:80 {
            address 192.168.56.22
            description 测试number2
        }
        /Common/test3:80 {
            address 192.168.56.11
            description 测试三
        }
        /Common/test6:80 {
            address 192.168.56.12
            description 111
            monitor /Common/http
        }
    }
    min-active-members 2
    monitor /Common/tcp
    queue-depth-limit 2
    queue-time-limit 1
    reselect-tries 3
}
ltm pool /Common/test {
    monitor /Common/http
}
ltm pool /Common/test5 { }
ltm rule /Common/test {

}
```

**思路**

开头的特定字符串和名字比较容易匹配，但是后面的值有两种情况。

- 第一种是空值，只有一个大括号括着一个空格`{ }`

- 第二种是有值的，格式如下

  ```
  ltm node 名称 {  #这里有换行
    值
  } #这里有换行
  ```

从中可知，`{`之前的字符串的匹配模式是一样的，不同的是后面。可以分开匹配，或者使用或`|`一起匹配

### **方案**

1、可以两种匹配方式分开匹配

- 匹配空pool：`pat = re.compile(r'(?<=ltm\spool\s)(.*?){(\s)}')`*
- 匹配非空pool：`pat = re.compile(r'(?-s:(?<=ltm\spool\s)(.*?){\n)(.*?)\n}', flags=re.S)`

2、使用`|`结合两种匹配模式

- 使用：`pat = re.compile(r'(?-s:(?<=ltm\spool\s)(.*?){)(\n.*?\n|\s)}', flags=re.S)`
  - 但当资源非空时，末行会有空行
- 使用：`pat = re.compile(r'(?-s:(?<=ltm\spool\s)(.*?{))(\n.*?\n}|\s})', flags=re.S)`
  - 但值的外部加上了`{}`

### **说明**

- `re.S`：让 `'.'` 特殊字符匹配任何字符，包括换行符；如果没有这个标记，`'.'` 就匹配 *除了* 换行符的其他任意字符。对应内联标记 `(?s)` 
- `(?-s:表达式)`：括号里的表达式取消`re.S`模式，即只能匹配单行字符串
- `(?<=ltm\spool\s)`：匹配以`ltm空格pool空格 `开头的字符串，但不包含`ltm空格pool空格 `

### **示例**

```python
import re

with open('bigip.conf', 'r', encoding='utf-8') as f:
    text = f.read()
    
pat = re.compile(r'(?-s:(?<=ltm\spool\s)(.*?{))(\n.*?\n}|\s})', flags=re.S)
source = pat.findall(text)
for i in source:
    print(f'[source name] {i[0]} {i[1]}')
```

**输出**

```
[source name] /Common/test1 {  }
[source name] /Common/mypool { 
    description 测试pool
    load-balancing-mode ratio-member
    members {
        /Common/test:80 {
            address 192.168.56.20
            description 测试number
            priority-group 1
            rate-limit 1
            ratio 3
        }
        /Common/test22:80 {
            address 192.168.56.22
            description 测试number2
        }
        /Common/test3:80 {
            address 192.168.56.11
            description 测试三
        }
        /Common/test6:80 {
            address 192.168.56.12
            description 111
            monitor /Common/http
        }
    }
    min-active-members 2
    monitor /Common/tcp
    queue-depth-limit 2
    queue-time-limit 1
    reselect-tries 3
}
[source name] /Common/test { 
    monitor /Common/http
}
[source name] /Common/test5 {  }
```

